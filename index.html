<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="description" content="A quantum circuit designer">
<meta name="keywords" content="quantum, quantum simulator, quantum computing, quantum circuit, circuits, quantum physics, physics">
<meta name="author" content="Lumorti">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3C!-- Created with Inkscape (http://www.inkscape.org/) --%3E%3Csvg xmlns:dc='http://purl.org/dc/elements/1.1/' xmlns:cc='http://creativecommons.org/ns%23' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:svg='http://www.w3.org/2000/svg' xmlns='http://www.w3.org/2000/svg' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' width='41.577381mm' height='41.577381mm' viewBox='0 0 41.577381 41.577381' version='1.1' id='svg8' inkscape:version='0.92.5 (2060ec1f9f, 2020-04-08)' sodipodi:docname='logo.svg'%3E%3Cdefs id='defs2' /%3E%3Csodipodi:namedview id='base' pagecolor='%23ffffff' bordercolor='%23666666' borderopacity='1.0' inkscape:pageopacity='0.0' inkscape:pageshadow='2' inkscape:zoom='1.4' inkscape:cx='78.784843' inkscape:cy='54.583581' inkscape:document-units='mm' inkscape:current-layer='layer1' showgrid='false' inkscape:snap-global='false' inkscape:window-width='931' inkscape:window-height='1016' inkscape:window-x='58' inkscape:window-y='27' inkscape:window-maximized='0' /%3E%3Cmetadata id='metadata5'%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=''%3E%3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E%3Cdc:type rdf:resource='http://purl.org/dc/dcmitype/StillImage' /%3E%3Cdc:title /%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cg inkscape:label='Capa 1' inkscape:groupmode='layer' id='layer1' transform='translate(-48.380955,-84.577377)'%3E%3Cpath style='opacity:1;vector-effect:none;fill:%2361baff;fill-opacity:0.98823529;stroke:none;stroke-width:2.89133859;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1' d='M -0.4375 0 L -0.4375 157.14258 L 156.70508 157.14258 L 156.70508 0 L -0.4375 0 z M 44.509766 44.947266 L 111.75781 44.947266 L 111.75781 112.19531 L 44.509766 112.19531 L 44.509766 44.947266 z ' transform='matrix(0.26458333,0,0,0.26458333,48.380955,84.577377)' id='rect815' /%3E%3Cpath style='opacity:1;vector-effect:none;fill:%23fbb400;fill-opacity:0.98823529;stroke:none;stroke-width:3.36025715;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1' d='M 14.152344 14.589844 L 14.152344 142.55273 L 142.11523 142.55273 L 142.11523 14.589844 L 14.152344 14.589844 z M 44.509766 44.947266 L 111.75781 44.947266 L 111.75781 112.19531 L 44.509766 112.19531 L 44.509766 44.947266 z ' transform='matrix(0.26458333,0,0,0.26458333,48.380955,84.577377)' id='rect817' /%3E%3Cpath style='opacity:1;vector-effect:none;fill:%2300a602;fill-opacity:0.98823529;stroke:none;stroke-width:1.79890728;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1' d='M 29.248047 29.6875 L 29.248047 127.45703 L 127.01758 127.45703 L 127.01758 29.6875 L 29.248047 29.6875 z M 44.509766 44.947266 L 111.75781 44.947266 L 111.75781 112.19531 L 44.509766 112.19531 L 44.509766 44.947266 z ' transform='matrix(0.26458333,0,0,0.26458333,48.380955,84.577377)' id='rect815-3' /%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml" />
<title>Agate</title>
<style>
	body {margin: 0; padding: 0; overflow: hidden;}
	#view {background-color: #ffffff; position: absolute; height: 100vh; width: 100%;}
	*:focus {outline: none;}
</style>
<script>

// TODO custom theta gates

// List of the loadable presets
var loadOpen = false;
var inputBox = null;
var openHover = false;
var openDims = [0, 0, 0, 0];
var presets = [
	["QASM File",       ""],
	["Preset: Tutorial", "OPENQASM%203.0%3B%0Ainclude%20%22stdgates.inc%22%3B%0Agate%20f0%20q0%2Cq1%20%2F%2F%200%2013%0A%7B%0Ax%20q0%3B%0Ax%20q1%3B%0A%7D%0A%2F%2F%20-4%20-14%20Add%20gates%20by%20dragging%20them%20from%20the%20toolbar%20at%20the%20top%0A%2F%2F%20-4%20-12%20Double-click%20and%20drag%20on%20the%20background%20to%20select%20multiple%20gates%0A%2F%2F%20-5%20-14%20%3E%0A%2F%2F%200%20-24%20Agate%20Tutorial%0A%2F%2F%20-5%20-12%20%3E%0A%2F%2F%20-5%20-21%20%3E%0A%2F%2F%20-4%20-5%20Controls%20can%20be%20added%20to%20any%20gate%20by%20double-clicking%20and%20dragging%0A%2F%2F%20-4%20-4%20Toggle%20controls%20by%20double-clicking%20on%20them%0A%2F%2F%20-5%20-5%20%3E%0A%2F%2F%20-5%20-4%20%3E%0A%2F%2F%20-4%20-3%20Remove%20controls%20by%20dragging%20them%20back%20to%20their%20parent%20gate%0A%2F%2F%20-5%20-3%20%3E%0A%2F%2F%20-4%20-13%20Remove%20gates%20by%20dragging%20them%20back%20to%20the%20toolbar%20(or%20with%20the%20delete%20key)%0A%2F%2F%20-5%20-13%20%3E%0A%2F%2F%20-4%20-20%20Zoom%20with%20the%20mouse%20wheel%20(or%20pinching%20on%20mobile)%0A%2F%2F%20-4%20-21%20Move%20the%20camera%20by%20dragging%20the%20background%0A%2F%2F%20-5%20-20%20%3E%0A%2F%2F%20-4%208%20Function%20definition%20gates%20will%20snap%20to%20existing%20circuits%0A%2F%2F%20-4%209%20They%20can%20then%20be%20double-clicked%20and%20dragged%20to%20create%20a%20function%20call%20gate%0A%2F%2F%20-5%208%20%3E%0A%2F%2F%20-5%209%20%3E%0A%2F%2F%200%20-23%20by%20Lumorti%0A%2F%2F%20-4%2010%20For%20now%20you%20can't%20place%20a%20function%20call%20inside%20a%20function%20definition%20(to%20prevent%20recursion)%0A%2F%2F%20-5%2010%20%3E%0A%2F%2F%20-5%2022%20%3E%0A%2F%2F%20-4%2035%20The%20URL%20can%20also%20be%20shared%2Fbookmarked%20and%20will%20result%20in%20the%20same%20circuit%0A%2F%2F%20-4%2022%20Text%20objects%20like%20these%20can%20be%20added%20to%20help%20label%20circuits%0A%2F%2F%20-4%2034%20Use%20the%20save%2Fload%20button%20to%20save%2Fload%20local%20QASM%20files%0A%2F%2F%20-4%2036%20The%20settings%20button%20allows%20the%20use%20of%20different%20simulation%20methods%20and%20various%20other%20tweaks%0A%2F%2F%20-5%2035%20%3E%0A%2F%2F%20-5%2034%20%3E%0A%2F%2F%20-5%2036%20%3E%0A%2F%2F%20-1%2026%20https%3A%2F%2Fgithub.com%2FLumorti%2FAgate%0A%2F%2F%20-4%2024%20Some%20LaTeX%20commands%20are%20also%20accepted%2C%20following%20a%20backslash%0A%2F%2F%20-3%2028%20%5C%20braket%7B1%7C4%7D%0A%2F%2F%20-3%2029%20%5C%20bra%7B1%7D%0A%2F%2F%201%2029%20%5Cbra%7B1%7D%0A%2F%2F%201%2028%20%5Cbraket%7B1%7C4%7D%0A%2F%2F%20-3%2030%20%5C%20ket%7B1%7D%0A%2F%2F%201%2030%20%5Cket%7B1%7D%0A%2F%2F%204%2028%20%5C%20sqrt2%0A%2F%2F%204%2029%201%20%5C%20pm%202%0A%2F%2F%208%2028%20%5Csqrt2%0A%2F%2F%208%2029%201%20%5Cpm%202%0A%2F%2F%208%2030%202%5Ctimes2%0A%2F%2F%204%2030%201%5C%20times2%0A%2F%2F%208%2031%201%5Ccdot2%0A%2F%2F%204%2031%201%5C%20cdot2%0A%2F%2F%204%2032%201%20%5C%20to%202%0A%2F%2F%208%2032%201%20%5Cto%202%0A%2F%2F%20-3%2031%20%5C%20langle%0A%2F%2F%201%2031%20%5Clangle%0A%2F%2F%20-3%2032%20%5C%20rangle%0A%2F%2F%201%2032%20%5Crangle%0A%2F%2F%20-5%2024%20%3E%0A%2F%2F%20-4%2038%20Keyboard%20shortcuts%20are%20also%20available%0A%2F%2F%20-5%2038%20%3E%0A%2F%2F%20-3%2043%20ctrl-z%0A%2F%2F%20-3%2040%20ctrl-c%0A%2F%2F%20-3%2041%20ctrl-x%0A%2F%2F%20-3%2042%20ctrl-v%0A%2F%2F%20-3%2039%20delete%0A%2F%2F%20-3%2044%20ctrl-shift-z%0A%2F%2F%201%2039%20delete%20the%20selected%20gate%2Fgates%0A%2F%2F%201%2040%20copy%20the%20selected%20gate%2Fgates%0A%2F%2F%201%2041%20cut%20the%20selected%20gate%2Fgates%0A%2F%2F%201%2042%20paste%20the%20stored%20gates%0A%2F%2F%201%2043%20undo%20the%20last%20change%0A%2F%2F%201%2044%20redo%20the%20last%20undo%0A%2F%2F%20-5%2023%20%3E%0A%2F%2F%20-4%2023%20Double%20click%20on%20one%20to%20edit%2C%20links%20are%20auto%20detected%0Aqubit%20q%5B2%5D%3B%20%2F%2F%20-1%20-9%0Ah%20q%5B0%5D%3B%0Ax%20q%5B0%5D%3B%0Aid%20q%5B1%5D%3B%0Aid%20q%5B1%5D%3B%0Aid%20q%5B1%5D%3B%0Aid%20q%5B1%5D%3B%0Ax%20q%5B1%5D%3B%0Aqubit%20q%5B2%5D%3B%20%2F%2F%202%2018%0Af0%20q%5B0%5D%2Cq%5B1%5D%3B%0Aqubit%20q%5B1%5D%3B%20%2F%2F%201%20-17%0Ax%20q%5B0%5D%3B%0Aqubit%20q%5B2%5D%3B%20%2F%2F%201%200%0Ah%20q%5B0%5D%3B%0Actrl%20%40%20x%20q%5B0%5D%2Cq%5B1%5D%3B%0Aqubit%20q%5B2%5D%3B%20%2F%2F%201%204%0Ah%20q%5B0%5D%3B%0Anegctrl%20%40%20x%20q%5B0%5D%2Cq%5B1%5D%3B%0A"],
	["Preset: Gates",    "OPENQASM%203.0%3B%0Ainclude%20%22stdgates.inc%22%3B%0A%2F%2F%206%200%20Hadamard%0A%2F%2F%207%201%20This%20allows%20the%20creation%20of%20superposition%2C%20where%0A%2F%2F%2015%205%20input%0A%2F%2F%2018%205%20output%20(unnormalised)%0A%2F%2F%2015%206%20%5Cket%7B0%7D%0A%2F%2F%2018%206%20%5Cket%7B0%7D%20%2B%20%5Cket%7B1%7D%0A%2F%2F%2015%207%20%5Cket%7B1%7D%0A%2F%2F%2018%207%20%5Cket%7B0%7D%20-%20%5Cket%7B1%7D%0A%2F%2F%207%202%20the%20circuit%20exists%20in%20multiple%20states%20at%20once%0A%2F%2F%206%20-7%20Pauli%20X%0A%2F%2F%207%20-6%20This%20is%20the%20equivalent%20of%20the%20classical%20NOT%20gate%0A%2F%2F%2015%20-4%20input%0A%2F%2F%2018%20-4%20output%0A%2F%2F%2015%20-3%20%5Cket%7B0%7D%0A%2F%2F%2018%20-3%20%5Cket%7B1%7D%0A%2F%2F%2015%20-2%20%5Cket%7B1%7D%0A%2F%2F%2018%20-2%20%5Cket%7B0%7D%0A%2F%2F%206%209%20Pauli%20Z%20(and%20other%20phase%20gates)%0A%2F%2F%207%2010%20These%20all%20add%20some%20kind%20of%20global%20phase%20to%20the%20state%2C%0A%2F%2F%207%2011%20but%20only%20if%20the%20input%20is%20%5Cket%7B1%7D%0A%2F%2F%2015%2028%20input%0A%2F%2F%2015%2013%20input%0A%2F%2F%2015%2017%20input%0A%2F%2F%2015%2021%20input%0A%2F%2F%2018%2028%20output%0A%2F%2F%2018%2013%20output%0A%2F%2F%2018%2017%20output%0A%2F%2F%2018%2021%20output%20(unnormalised)%0A%2F%2F%2015%2029%20%5Cket%7B0%7D%0A%2F%2F%2015%2030%20%5Cket%7B1%7D%0A%2F%2F%2015%2014%20%5Cket%7B0%7D%0A%2F%2F%2015%2015%20%5Cket%7B1%7D%0A%2F%2F%2015%2018%20%5Cket%7B0%7D%0A%2F%2F%2015%2019%20%5Cket%7B1%7D%0A%2F%2F%2015%2022%20%5Cket%7B0%7D%0A%2F%2F%2015%2023%20%5Cket%7B1%7D%0A%2F%2F%2018%2029%20i%20%5Cket%7B1%7D%0A%2F%2F%2018%2030%20-i%20%5Cket%7B0%7D%0A%2F%2F%2018%2014%20%5Cket%7B0%7D%0A%2F%2F%2018%2015%20-%20%5Cket%7B1%7D%0A%2F%2F%2018%2018%20%5Cket%7B0%7D%0A%2F%2F%2018%2019%20i%20%5Cket%7B1%7D%0A%2F%2F%2018%2023%20(1%2Bi)%20%5Cket%7B1%7D%0A%2F%2F%2018%2022%20%5Cket%7B0%7D%0A%2F%2F%206%2025%20Pauli%20Y%0A%2F%2F%207%2026%20Performs%20a%20NOT%20as%20well%20as%20adding%20a%20phase%0A%2F%2F%2010%20-10%20Agate%20Gates%20List%0A%2F%2F%2011%20-9%20by%20Lumorti%0A%2F%2F%207%203%20Results%20in%20a%2050%2F50%20chance%20of%20measuring%20either%0A%2F%2F%2015%2035%20input%0A%2F%2F%2018%2035%20output%0A%2F%2F%2015%2036%20%5Cket%7B00%7D%0A%2F%2F%2018%2036%20%5Cket%7B00%7D%0A%2F%2F%206%2032%20Swap%0A%2F%2F%207%2033%20Swaps%20the%20two%20qubits%0A%2F%2F%2015%2037%20%5Cket%7B01%7D%0A%2F%2F%2018%2037%20%5Cket%7B10%7D%0A%2F%2F%2015%2038%20%5Cket%7B10%7D%0A%2F%2F%2018%2038%20%5Cket%7B01%7D%0A%2F%2F%2015%2039%20%5Cket%7B11%7D%0A%2F%2F%2018%2039%20%5Cket%7B11%7D%0A%2F%2F%206%2010%20%3E%0A%2F%2F%206%201%20%3E%0A%2F%2F%206%203%20%3E%0A%2F%2F%206%20-6%20%3E%0A%2F%2F%206%2026%20%3E%0A%2F%2F%206%2033%20%3E%0Aqubit%20q%5B1%5D%3B%20%2F%2F%209%206%0Ah%20q%5B0%5D%3B%0Aqubit%20q%5B1%5D%3B%20%2F%2F%209%20-3%0Ax%20q%5B0%5D%3B%0Aqubit%20q%5B1%5D%3B%20%2F%2F%209%2029%0Ay%20q%5B0%5D%3B%0Aqubit%20q%5B1%5D%3B%20%2F%2F%209%2014%0Az%20q%5B0%5D%3B%0Aqubit%20q%5B1%5D%3B%20%2F%2F%209%2018%0As%20q%5B0%5D%3B%0Aqubit%20q%5B1%5D%3B%20%2F%2F%209%2022%0At%20q%5B0%5D%3B%0Aqubit%20q%5B2%5D%3B%20%2F%2F%209%2036%0Aswap%20q%5B1%5D%2Cq%5B0%5D%3B%0A"],
	["Preset: Grover's", "OPENQASM%203.0%3B%0Ainclude%20%22stdgates.inc%22%3B%0Agate%20f2%20q0%2Cq1%20%2F%2F%20-2%2015%0A%7B%0Az%20q0%3B%0Az%20q1%3B%0Actrl%20%40%20z%20q0%2Cq1%3B%0A%7D%0Agate%20f1%20q0%2Cq1%20%2F%2F%20-2%2010%0A%7B%0Actrl%20%40%20z%20q0%2Cq1%3B%0A%7D%0Agate%20f0%20q0%2Cq1%20%2F%2F%20-2%205%0A%7B%0Ah%20q0%3B%0Ah%20q1%3B%0A%7D%0A%2F%2F%203%206%20this%20function%20create%20or%20destroys%20the%20search%20space%0A%2F%2F%203%2011%20this%20function%20adds%20a%20negative%20phase%20to%20the%20state%20we%20want%20to%20find%0A%2F%2F%203%2012%20(in%20this%20case%3A%20%5Cket%7B11%7D%20%5Cto%20-%5Cket%7B11%7D)%0A%2F%2F%204%2016%20this%20function%20rotates%20anything%20that's%20not%20%5Cket%7B00%7D%20to%20have%20negative%20phase%0A%2F%2F%204%2017%20(i.e.%20anything%20that%20didn't%20become%20zero%20when%20we%20destroy%20the%20search%20space)%0A%2F%2F%20-3%20-6%20This%20famous%20quantum%20algorithm%20amplifies%20the%20chance%20of%20measuring%20%0A%2F%2F%20-3%20-5%20a%20certain%20state%20from%20a%20big%20list%20of%20possible%20states%2C%20effectively%20%22finding%22%20a%20state%0A%2F%2F%203%207%20(in%20this%20case%3A%20a%20full%20superposition)%0A%2F%2F%200%20-9%20Grover's%20Algorithm%20Implementation%0A%2F%2F%20-1%2020%20Sources%3A%0A%2F%2F%200%2021%20https%3A%2F%2Fqiskit.org%2Ftextbook%2Fch-algorithms%2Fgrover.html%0A%2F%2F%200%2022%20https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FGrover%2527s_algorithm%0A%2F%2F%200%20-8%20by%20Lumorti%0A%2F%2F%20-3%20-3%20Whilst%20classically%20searching%20a%20list%20of%20N%20items%20takes%20at%20most%20N%20checks%2C%0A%2F%2F%20-3%20-2%20this%20algorithm%20only%20requires%20at%20most%20%5CsqrtN%20checks%0Aqubit%20q%5B2%5D%3B%20%2F%2F%202%201%0Af0%20q%5B0%5D%2Cq%5B1%5D%3B%0Af1%20q%5B0%5D%2Cq%5B1%5D%3B%0Af0%20q%5B0%5D%2Cq%5B1%5D%3B%0Af2%20q%5B0%5D%2Cq%5B1%5D%3B%0Af0%20q%5B0%5D%2Cq%5B1%5D%3B%0A"],
];

// Stuff for svgs
var svgPadding = 30;
var svgString = "";
var svgMinX = 99999;
var svgMaxX = -99999;
var svgMinY = 99999;
var svgMaxY = -99999;

// Save types
var saveOpen = false;
var outputBox = null;
var saveHover = false;
var saveDims = [0, 0, 0, 0];
var saveTypes = [
	"QASM 3.0",
	"QASM 2.0",
	"SVG",
	"Unitary CSV",
];

// The gates to put on the toolbar
var numGatesToShow = 5;
var toolbarIndex = 0;
var toolbarGates = [
	"H",
	"X",
	"Y",
	"Z",
	"sub",
	"S",
	"T",
	"I",
	"swap",
	"text",
];

// User-modifiable settings 
var canEdit = true;
var showFPS = false;
var drawGrid = true;
var simMethod = "Statevector";
var numRepeats = 1000;
var cutoffThresh = 0.1;
var doubleClickMilli = 300;
var initialZoom = 1.0;
var qasmVersion = 3;
var maxHistory = 10;

// Stuff for the settings menu
var settingsOpen = false;
var fpsBox = null;
var gridBox = null;
var simBox = null;
var repeatsBox = null;

// Empty global vars to be initialised later
var canvas = null;
var ctx = null;
var copyElement = null;
var linkObject = null;

// For managing the history
var qasmHistory = [];
var historyIndex = -1;
var noHistory = false;

// The list of gates
var gates = [];
var gatesInit = [];
var gateOptions = -1;

// Which gate is current selected
var justCreateMulti = false;
var selected = -1;
var hover = -1;
var nextID = 0;
var nextFunctionID = 0;
var dragOffset = 0;
var showDelete = false;
var selectStartX = 0;
var selectEndX = 0;
var selectStartY = 0;
var selectEndY = 0;
var selectionArray = [];
var lineStartEnds = [];
var qubitsWithGates = [];
var funcStartEnds = [];
var funcUnitaries = [];

// General vars
var mx = 0;
var my = 0;
var onMobile = 0;
var gateSizeFixed = 50;
var debugData = "";
var gridYFixed = 60;
var gridXFixed = 60;
var fontSize = initialZoom*35;
var gateSize = initialZoom*gateSizeFixed;
var gridY = initialZoom*gridYFixed;
var gridX = initialZoom*gridXFixed;
var spacing = 0.8;
var toolbarWidth = -1;
var toolbarHeight = -1;
var maxRecDepth = 5;

// For FPS checking
var frames = 0;
var fps = 0;
var lastFPSCheck = 0;

// For dragging the canvas around
var offsetX = 0;
var offsetY = 0;
var prevTouchX = 0;
var prevTouchY = 0;

// Stuff for mobile
var isPinching = false;
var mobileOffsetY = 0;
var lastPinchDist = -1;
var browser = "";
var inPrompt = false;

// For the tips window
var helpOpen = true;
var tipInd = 0;
var tips = [
	["open",            "If you're new, load the tutorial",   "using the open icon at the top"],
	["H",               "Create gates by dragging them",      "from the toolbar at the top"],
	["controlFilled",   "Double-click and drag on a",         "gate to create a control"],
	["controlUnfilled", "Double-click on controls",           "to toggle them"],
	["sub",             "Function definition gates",          "snap to existing circuits"],
	["fun0",            "Double-click and drag a function",   "to create a call gate"],
	["X",               "Double-click and drag nothing",      "to select multiple gates"],
];

// For timings
var lastClickTime = -1;
var lastSimTime = -1;
var circuitUpdates = 1;
var recalcRecs = true;
var inputs = [[]];
var results = [[]];

// Generate random numbers
var numRands = numRepeats * 4;
var randNums = [];
for (var i=0; i<numRands; i++) {
	randNums.push(Math.random());
}

// Pretty print a matrix
function printMatrix(arr) {
	for (var i=0; i<arr.length; i++) {
		var arrText = "";
		for (var j=0; j<arr[i].length; j++) {
			arrText += arr[i][j] + " ";
		}
		console.log(arrText);
	}
}

// Called on body ready
function init(newInstance=false, recalc=false) {

	// If this is triggering from the Firefox mobile prompt resize
	if (inPrompt) {return;}

	// Reset things
	loadOpen = false;
	saveOpen = false;
	canEdit = true;
	showFPS = false;

	// Get the browser 
	if (navigator.userAgent.indexOf("Chrome") > 0) {
		browser = "Chrome";
	} else if (navigator.userAgent.indexOf("Firefox") > 0) {
		browser = "Firefox";
	}

	// Initialise the canvas
	canvas = document.getElementById("view");
	ctx = canvas.getContext("2d");

	// Make sure it's a high DPI canvas 
	canvas.width = window.innerWidth;
	canvas.height = window.innerWidth;
	canvas.style.width = window.innerWidth + "px";
	canvas.style.height = window.innerHeight + "px";
	ctx.canvas.width  = window.innerWidth;
	ctx.canvas.height = window.innerHeight;

	// If not refeshing/resizing
	if (newInstance) {

		// Add listeners for mouse events 
		canvas.addEventListener('mousemove', mouseMove);
		canvas.addEventListener('mousedown', mouseDown);
		canvas.addEventListener('mouseup',   mouseUp);
		canvas.addEventListener('wheel',     mouseWheel);

		// For keyboard events 
		window.addEventListener('keydown',   keyDown);
		copyElement = document.getElementById("hiddenText");

		// And for touch events
		canvas.addEventListener("touchstart",  touchHandler, true);
		canvas.addEventListener("touchmove",   touchHandler, true);
		canvas.addEventListener("touchend",    touchHandler, true);
		canvas.addEventListener("touchcancel", touchHandler, true);

		// Setup the hidden load element 
		inputBox = document.createElement("SELECT");
		inputBox.style.position = "absolute";
		inputBox.style.font = "20px Arial";
		inputBox.style.padding = "10px";
		inputBox.style.zIndex = "100";
		for (var k=0; k<presets.length; k++) {
			var option = document.createElement("option");
			option.text = presets[k][0];
			inputBox.add(option);
		}
		document.getElementsByTagName("BODY")[0].appendChild(inputBox);

		// Setup the hidden save element 
		outputBox = document.createElement("SELECT");
		outputBox.style.position = "absolute";
		outputBox.style.font = "20px Arial";
		outputBox.style.padding = "10px";
		outputBox.style.zIndex = "101";
		for (var k=0; k<saveTypes.length; k++) {
			var option = document.createElement("option");
			option.text = saveTypes[k];
			outputBox.add(option);
		}
		document.getElementsByTagName("BODY")[0].appendChild(outputBox);

		// Setup the hidden FPS checkbox
		fpsBox = document.createElement("INPUT");
		fpsBox.setAttribute("type", "checkbox");
		fpsBox.style.position = "absolute";
		fpsBox.style.font = "20px Arial";
		fpsBox.style.padding = "10px";
		fpsBox.style.zIndex = "101";
		fpsBox.style.height = "25px";
		fpsBox.style.width = "25px";
		fpsBox.onchange = function() {
			showFPS = !showFPS;
		};
		document.getElementsByTagName("BODY")[0].appendChild(fpsBox);

		// Setup the hidden grid checkbox
		gridBox = document.createElement("INPUT");
		gridBox.setAttribute("type", "checkbox");
		gridBox.style.position = "absolute";
		gridBox.style.font = "20px Arial";
		gridBox.style.padding = "10px";
		gridBox.style.zIndex = "101";
		gridBox.style.height = "25px";
		gridBox.style.width = "25px";
		gridBox.checked = drawGrid;
		gridBox.onchange = function() {
			drawGrid = !drawGrid;
		};
		document.getElementsByTagName("BODY")[0].appendChild(gridBox);

		// Setup the hidden sim method box
		simBox = document.createElement("SELECT");
		simBox.style.position = "absolute";
		simBox.style.font = "20px Arial";
		simBox.style.padding = "10px";
		simBox.style.zIndex = "101";
		simBox.style.boxSizing = "border-box";
		opts = ["Statevector", "Measurements", "Unitary"];
		for (var i=0; i<opts.length; i++) {
			var option = document.createElement("option");
			option.text = opts[i];
			simBox.add(option);
		}
		simBox.onchange = function() {
			simMethod = simBox.options[simBox.selectedIndex].text;
			circuitUpdates = 1;
		};
		document.getElementsByTagName("BODY")[0].appendChild(simBox);

		// Setup the hidden repeats box
		repeatsBox = document.createElement("INPUT");
		repeatsBox.setAttribute("type", "number");
		repeatsBox.style.position = "absolute";
		repeatsBox.style.font = "20px Arial";
		repeatsBox.style.padding = "10px";
		repeatsBox.style.zIndex = "101";
		repeatsBox.style.boxSizing = "border-box";
		repeatsBox.style.display = "none";
		repeatsBox.value = numRepeats;
		repeatsBox.onchange = function() {
			numRepeats = repeatsBox.value;
			circuitUpdates = 1;
		};
		document.getElementsByTagName("BODY")[0].appendChild(repeatsBox);

		// Get the link object
		linkObject = document.getElementById("hiddenURL");

	}

	// Check if mobile 
	if (gridXFixed*(numGatesToShow+4)+10 > 0.9*window.innerWidth) {
		onMobile = 1;
	} else if (window.innerHeight < 400) {
		onMobile = 2;
	}

	// Changes if on mobile (vertical)
	if (onMobile == 1) {

		// Zoom out a bit 
		var change = 1.0 - 0.4;
		gridY = initialZoom * gridYFixed * change;
		gridX = initialZoom * gridXFixed * change;
		gateSize = initialZoom * gateSizeFixed * change;
		fontSize = initialZoom * 35 * change;

		// Show less gates at once on mobile
		numGatesToShow = 3;

		// Add the gate summoning buttons 
		toolbarHeight = gridYFixed*2+10;
		toolbarWidth = gridXFixed*(numGatesToShow+2)+10;
		toolbarOffsetX = window.innerWidth / 2 - toolbarWidth / 2;
		toolbarRel = (toolbarOffsetX / gridXFixed);
		gates = [];
		toolbarIndex = 0;
		gates.push({"letter": "left",   "y": 0.33, "x": 0.15+toolbarRel, "size": 1, "attached": [], "og": -1, "draggable": false})
		for (var i=0; i<toolbarGates.length; i++) {
			gates.push({"letter": toolbarGates[i], "attached": [], "og": -1, "y": 0.33, "x": (i%numGatesToShow)+1.15+toolbarRel, "size": 1, "draggable": false})
		}
		gates.push({"letter": "right",  "y": 0.33, "x": numGatesToShow+1.2+toolbarRel, "attached": [], "og": -1, "size": 1, "draggable": false})
		gates.push({"letter": "open", "attached": [], "og": -1, "y": 1.27, "x": 1.25+toolbarRel, "size": 1, "draggable": false})
		gates.push({"letter": "save", "attached": [], "og": -1, "y": 1.43, "x": 2.25+toolbarRel, "size": 1, "draggable": false})
		gates.push({"letter": "settings", "attached": [], "og": -1, "y": 1.33, "x": 3.15+toolbarRel, "size": 1, "draggable": false})
		gatesInit = gates.slice();
		gateOptions = gates.length;

	} else {

		// Zoom out a bit 
		var change = 1.0 - 0.2;
		gridY = initialZoom * gridYFixed * change;
		gridX = initialZoom * gridXFixed * change;
		gateSize = initialZoom * gateSizeFixed * change;
		fontSize = initialZoom * 35 * change;

		// Show more gates if possible
		numGatesToShow = 5;

		// Add the gate summoning buttons 
		toolbarHeight = gateSizeFixed+20;
		toolbarWidth = gridXFixed*(numGatesToShow+5);
		toolbarOffsetX = window.innerWidth / 2 - toolbarWidth / 2;
		toolbarRel = (toolbarOffsetX / gridXFixed);
		gates = [];
		toolbarIndex = 0;
		gates.push({"letter": "left",   "y": 0.33, "x": 0.2+toolbarRel, "size": 1, "attached": [], "og": -1, "draggable": false})
		for (var i=0; i<toolbarGates.length; i++) {
			gates.push({"letter": toolbarGates[i], "attached": [], "og": -1, "y": 0.33, "x": (i%numGatesToShow)+1.2+toolbarRel, "size": 1, "draggable": false})
		}
		gates.push({"letter": "right",  "y": 0.33, "x": numGatesToShow+1.2+toolbarRel, "attached": [], "og": -1, "size": 1, "draggable": false})
		gates.push({"letter": "open", "attached": [], "og": -1, "y": 0.27, "x": numGatesToShow+1.9+toolbarRel, "size": 1, "draggable": false})
		gates.push({"letter": "save", "attached": [], "og": -1, "y": 0.43, "x": numGatesToShow+2.9+toolbarRel, "size": 1, "draggable": false})
		gates.push({"letter": "settings", "attached": [], "og": -1, "y": 0.35, "x": numGatesToShow+3.8+toolbarRel, "size": 1, "draggable": false})
		gatesInit = gates.slice();
		gateOptions = gates.length;

	}

	// If URL contains QASM info, use it
	if (document.location.hash.length > 1) {

		// Start with the whole hash
		var toProcess = document.location.hash.substr(1);

		// Prevent edits, hide toolbar etc. 
		if (toProcess.substr(0,4) == "view") {
			canEdit = false;
			toProcess = toProcess.substr(4);
		} 

		// Override the sim method
		if (toProcess.substr(0,7) == "unitary") {
			simMethod = "Unitary";
			toProcess = toProcess.substr(7);
		} 
		if (toProcess.substr(0,12) == "measurements") {
			simMethod = "Measurements";
			toProcess = toProcess.substr(12);
		} 
		if (toProcess.substr(0,11) == "statevector") {
			simMethod = "Statevector";
			toProcess = toProcess.substr(11);
		} 

		// Get it and process it
		asQasm = decodeURIComponent(toProcess);

		// Load the gates from this
		fromQASM(asQasm);

		// Don't show the help
		helpOpen = false;

	}

	// Update the sim method drop down
	for (var i=0; i<simBox.options.length; i++) {
		if (simBox.options[i].text == simMethod) {
			simBox.selectedIndex = i;
			break;
		}
	}

	// Whether to resim the circuit
	if (recalc) {
		circuitUpdates = 2;
	} else {
		circuitUpdates = 0;
	}

	// Only create the drawing instance once
	if (newInstance) {
		redraw();
	}

}

// Given a letter and a position, draw a gate
function drawGate(letter, x, y, isSelected, size, fixedSize=false) {

	// If it's a filled control
	if (letter == "controlFilled") {

		// Draw the circle
		ctx.lineWidth = fontSize/7;
		if (!isSelected) {
			ctx.fillStyle = "#555555";
			ctx.strokeStyle = "#555555";
		} else {
			ctx.fillStyle = "#888888";
			ctx.strokeStyle = "#888888";
		}
		ctx.beginPath();
		ctx.arc(x, y, gateSize/4, 0, 2 * Math.PI, false);
		ctx.fill();
		ctx.stroke();
		svgCircle(x, y, gateSize/4, ctx.fillStyle, ctx.strokeStyle, ctx.lineWidth);

	// If it's an unfilled control
	} else if (letter == "controlUnfilled") {

		// Draw the circle
		ctx.lineWidth = fontSize/7;
		if (!isSelected) {
			ctx.strokeStyle = "#555555";
		} else {
			ctx.strokeStyle = "#888888";
		}
		ctx.fillStyle = "#ffffff";
		ctx.beginPath();
		ctx.arc(x, y, gateSize/4, 0, 2 * Math.PI, false);
		ctx.fill();
		ctx.stroke();
		svgCircle(x, y, gateSize/4, ctx.fillStyle, ctx.strokeStyle, ctx.lineWidth);

	// If it's an subroutine definition
	} else if (letter.substr(0,3) == "sub") {

		// If not a toolbar gate
		if (!fixedSize) {

			// Draw the box
			if (!isSelected) {
				ctx.fillStyle = "#16a300";
			} else {
				ctx.fillStyle = "#107800";
			}
			ctx.fillRect(x-gateSize/2, y-gateSize/2, gateSize, gateSize+gridY*(size-1));
			svgRect(x-gateSize/2, y-gateSize/2, gateSize, gateSize+gridY*(size-1), ctx.fillStyle);
			
			// Draw the letter 
			ctx.fillStyle = "#ffffff";
			if (letter.length > 3) {
				ctx.font = (fontSize*0.9-2*(letter.length-4)) + "px Arial";
				ctx.fillText(letter.substr(3), gridX*0.28+x-4*(letter.length-4)-gateSize/2, gridY*0.59+y-gateSize/2);
				svgText(letter.substr(3), gridX*0.28+x-4*(letter.length-4)-gateSize/2, gridY*0.59+y-gateSize/2, fontSize*0.9-2*(letter.length-4), ctx.measureText(letter.substr(3)).width, ctx.fillStyle);
			} else {
				ctx.font = (fontSize*0.9)+"px Arial";
				ctx.fillText("F", gridX*0.28+x-gateSize/2, gridY*0.59+y-gateSize/2);
			}

		// If a toolbar gate (and thus fixed sizes should be used)
		} else {

			// Draw the box
			if (!isSelected) {
				ctx.fillStyle = "#16a300";
			} else {
				ctx.fillStyle = "#107800";
			}
			ctx.fillRect(x-gateSizeFixed/2, y-gateSizeFixed/2, gateSizeFixed, gateSizeFixed+gridY*(size-1));
			
			// Draw the letter
			ctx.fillStyle = "#ffffff";
			if (letter.length > 3) {
				ctx.font = (30/(letter.length-3)) + "px Arial";
				ctx.fillText(letter.substr(3), gridXFixed*0.28+x-gateSizeFixed/2, gridYFixed*0.59+y-gateSizeFixed/2);
			} else {
				ctx.font = "30px Arial";
				ctx.fillText("F", gridXFixed*0.28+x-gateSizeFixed/2, gridYFixed*0.59+y-gateSizeFixed/2);
			}

		}

	// If it's an subroutine call 
	} else if (letter.substr(0,3) == "fun" || letter == "?") {

		// If not a toolbar gate 
		if (!fixedSize) {

			// Draw the box
			if (!isSelected) {
				ctx.fillStyle = "#16a300";
			} else {
				ctx.fillStyle = "#107800";
			}
			ctx.fillRect(x-gateSize/2, y-gateSize/2, gateSize, gateSize+gridY*(size-1));
			svgRect(x-gateSize/2, y-gateSize/2, gateSize, gateSize+gridY*(size-1), ctx.fillStyle);
			
			// Draw the letter
			ctx.fillStyle = "#ffffff";
			if (letter == "?") {
				ctx.font = (fontSize*0.9)+"px Arial";
				ctx.fillText("?", 0.28*gridX+x-gateSize/2, 0.59*gridY+y-gateSize/2);
				svgText("?", 0.28*gridX+x-gateSize/2, 0.28*gridX+x-gateSize/2, (fontSize*0.9), ctx.measureText("?").width, ctx.fillStyle);
			} else {
				ctx.font = (fontSize*0.9-2*(letter.length-4)) + "px Arial";
				ctx.fillText(letter.substr(3), 0.28*gridX-4*(letter.length-4)+x-gateSize/2, 0.59*gridY+y-gateSize/2);
				svgText(letter.substr(3), 0.28*gridX-4*(letter.length-4)+x-gateSize/2, 0.59*gridY+y-gateSize/2, (fontSize*0.9), ctx.measureText(letter.substr(3)).width, ctx.fillStyle);
			}

		// If a toolbar gate (and thus fixed sizes should be used)
		} else {

			// Draw the box
			if (!isSelected) {
				ctx.fillStyle = "#16a300";
			} else {
				ctx.fillStyle = "#107800";
			}
			ctx.fillRect(x-gateSizeFixed/2, y-gateSizeFixed/2, gateSizeFixed, gateSizeFixed+gridYFixed*(size-1));
			
			// Draw the letter
			ctx.fillStyle = "#ffffff";
			if (letter == "?") {
				ctx.font = "30px Arial";
				ctx.fillText("?", 0.28*gridXFixed+x-gateSizeFixed/2, 0.59*gridYFixed+y-gateSizeFixed/2);
			} else {
				ctx.font = (fontSize*0.9-2*(letter.length-4)) + "px Arial";
				ctx.fillText(letter.substr(3), 0.28*gridXFixed-4*(letter.length-4)+x-gateSizeFixed/2, 0.59*gridYFixed+y-gateSizeFixed/2);
			}

		}
		
	// If it's the link go button 
	} else if (letter == "go") {

		// Draw the arrow
		if (!isSelected) {
			ctx.fillStyle = "#555555";
		} else {
			ctx.fillStyle = "#888888";
		}
		ctx.beginPath();
		ctx.moveTo(x-gateSize/3, y-gateSize/3);
		ctx.lineTo(x-gateSize/3, y+gateSize/3);
		ctx.lineTo(x, y);
		ctx.fill();

	// If it's the whole swap gate 
	} else if (letter == "swap") {

		// Draw the curved section
		if (!isSelected) {
			ctx.strokeStyle = "#555555";
		} else {
			ctx.strokeStyle = "#888888";
		}
		ctx.lineWidth = 3;
		ctx.beginPath();
		ctx.arc(x-gateSizeFixed/3, y, gateSizeFixed/3, 1.5*Math.PI, 0);
		ctx.stroke();
		ctx.beginPath();
		ctx.arc(x+gateSizeFixed/3, y, gateSizeFixed/3, 1*Math.PI, 1.5*Math.PI);
		ctx.stroke();
		ctx.beginPath();
		ctx.arc(x-gateSizeFixed/3, y, gateSizeFixed/3, 0*Math.PI, 0.5*Math.PI);
		ctx.stroke();
		ctx.beginPath();
		ctx.arc(x+gateSizeFixed/3, y, gateSizeFixed/3, 0.5*Math.PI, 1.0*Math.PI);
		ctx.stroke();

	// If it's the top part of a swap gate
	} else if (letter == "swaptop") {

		// Clear the standard qubit line 
		ctx.fillStyle = "#ffffff";
		ctx.fillRect(x-gridX/2+fontSize/70, y-gridY/8, gridX-fontSize/35, gridY/2);
		svgRect(x-gridX/2+fontSize/70, y-gridY/8, gridX-fontSize/35, gridY/2, ctx.fillStyle);

		// Draw the curved section
		if (!isSelected) {
			ctx.strokeStyle = "#aaaaaa";
		} else {
			ctx.strokeStyle = "#888888";
		}
		ctx.lineWidth = fontSize/7;
		ctx.beginPath();
		ctx.arc(x-gridX/2, y+gridY/2, gridX/2, 1.5*Math.PI, 0);
		ctx.stroke();
		svgArc(x-gridX/2, y, x, y, x, y+gridY/2, ctx.strokeStyle, ctx.lineWidth);
		ctx.beginPath();
		ctx.arc(x+gridX/2, y+gridY/2, gridX/2, 1*Math.PI, 1.5*Math.PI);
		ctx.stroke();
		svgArc(x+gridX/2, y, x, y, x, y+gridY/2, ctx.strokeStyle, ctx.lineWidth);

	// If it's the bottom part of a swap gate 
	} else if (letter == "swapbottom") {

		// Clear the standard qubit line
		ctx.fillStyle = "#ffffff";
		ctx.fillRect(x-gridX/2+fontSize/70, y-gridY/3, gridX-fontSize/35, gridY/2);
		svgRect(x-gridX/2+fontSize/70, y-gridY/3, gridX-fontSize/35, gridY/2, ctx.fillStyle);

		// Draw the curved section
		if (!isSelected) {
			ctx.strokeStyle = "#aaaaaa";
		} else {
			ctx.strokeStyle = "#888888";
		}
		ctx.lineWidth = fontSize/7;
		ctx.beginPath();
		ctx.arc(x-gridX/2, y-gridY/2, gridX/2, 0*Math.PI, 0.5*Math.PI);
		ctx.stroke();
		svgArc(x-gridX/2, y, x, y, x, y-gridY/2, ctx.strokeStyle, ctx.lineWidth);
		ctx.beginPath();
		ctx.arc(x+gridX/2, y-gridY/2, gridX/2, 0.5*Math.PI, 1.0*Math.PI);
		ctx.stroke();
		svgArc(x+gridX/2, y, x, y, x, y-gridY/2, ctx.strokeStyle, ctx.lineWidth);

	// If it's the create text icon 
	} else if (letter == "text") {

		// Draw the text
		ctx.font = "40px Serif";
		if (!isSelected) {
			ctx.fillStyle = "#555555";
		} else {
			ctx.fillStyle = "#888888";
		}
		ctx.fillText("T", x-14, y+14);
		
	// If it's a gate-like text object 
	} else if (letter.substr(0,4) == "text") {

		// The text of the gate
		var gateText = letter.substr(4);

		// If it's a link
		if (gateText.substr(0, 4) == "http") {
			
			// Fill a box behind
			ctx.font = fontSize + "px Arial";
			var textWidth = ctx.measureText(gateText).width;
			ctx.fillStyle = "#ffffff";
			ctx.fillRect(x-gridX*0.25, y-gridY/2+1, textWidth+gridX*0.05, gridY-2);

			// Draw the text
			if (!isSelected) {
				ctx.fillStyle = "#037a8c";
			} else {
				ctx.fillStyle = "#003740";
			}
			ctx.fillText(gateText, floor(x-gridX/2+gridX*0.2), floor(y+gridY/2-fontSize/2));
			svgText(gateText, x-gridX/2+gridX*0.2, y+gridY/2-fontSize/2, fontSize, ctx.measureText(gateText).width, ctx.fillStyle);

		// If it's normal text
		} else {

			// More complex LaTeX replaces
			gateText = gateText.replace(/\\braket{(.+?)}/g, "\\langle$1\\rangle");
			gateText = gateText.replace(/\\bra{(.+?)}/g, "\\langle$1|");
			gateText = gateText.replace(/\\ket{(.+?)}/g, "|$1\\rangle");
			
			// Simple LaTeX replaces
			gateText = gateText.replace(/\\pm/g, "\u00B1");
			gateText = gateText.replace(/\\sqrt/g, "\u221A");
			gateText = gateText.replace(/\\rangle/g, "\u27E9");
			gateText = gateText.replace(/\\langle/g, "\u27E8");
			gateText = gateText.replace(/\\to/g, "\u2192");
			gateText = gateText.replace(/\\cdot/g, "\u22C5");
			gateText = gateText.replace(/\\times/g, "\u00D7");
			gateText = gateText.replace(/\\check/g, "\u2713");

			// Fill a box behind
			ctx.font = fontSize + "px Arial";
			var textWidth = ctx.measureText(gateText).width;
			ctx.fillStyle = "#ffffff";
			ctx.fillRect(x-gridX*0.25, y-gridY/2+1, textWidth+gridX*0.05, gridY-2);

			// Set the colour for both text and LaTeX
			if (!isSelected) {
				ctx.fillStyle = "#555555";
				ctx.strokeStyle = "#555555";
			} else {
				ctx.fillStyle = "#888888";
				ctx.strokeStyle = "#888888";
			}

			// Draw the text
			ctx.fillText(gateText, floor(x-gridX/2+gridX*0.2), floor(y+gridY/2-fontSize/2));
			svgText(gateText, x-gridX/2+gridX*0.2, y+gridY/2-fontSize/2, fontSize, ctx.measureText(gateText).width, ctx.fillStyle);

		}

	// If it's the open settings icon 
	} else if (letter == "settings") {

		// Colours
		if (!isSelected) {
			ctx.fillStyle = "#555555";
		} else {
			ctx.fillStyle = "#888888";
		}

		// Draw the hamburger menu icon
		roundRect(ctx, x-15, y-12, 30, 5, 3, true, false);
		roundRect(ctx, x-15, y-2, 30, 5, 3, true, false);
		roundRect(ctx, x-15, y+8, 30, 5, 3, true, false);

	// If it's the logo 
	} else if (letter == "logo") {

		// The outer blue
		ctx.fillStyle = "#61baff";
		ctx.fillRect(x-gateSize*size*0.5, y-gateSize*size*0.5, gateSize*size, gateSize*size);

		// The middle yellow
		ctx.fillStyle = "#fbb400";
		ctx.fillRect(x-gateSize*size*0.4, y-gateSize*size*0.4, gateSize*size*0.8, gateSize*size*0.8);

		// The inner green
		ctx.fillStyle = "#00a602";
		ctx.fillRect(x-gateSize*size*0.3, y-gateSize*size*0.3, gateSize*size*0.6, gateSize*size*0.6);

		// Get rid of the center
		ctx.fillStyle = "#dddddd";
		ctx.fillRect(x-gateSize*size*0.2, y-gateSize*size*0.2, gateSize*size*0.4, gateSize*size*0.4);

	// If it's the load/open icon
	} else if (letter == "open") {

		// Colours
		backCol = "#fcb603";
		paperCol = "#ffffff";
		frontCol = "#d49f00";

		// To save adding this everywhere
		x = x-gateSizeFixed/2;
		y = y-gateSizeFixed/2+10;

		// Draw the back bit of the folder
		ctx.fillStyle = backCol;
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x, y+40);
		ctx.lineTo(x+40, y+40);
		ctx.lineTo(x+40, y);
		ctx.fill();

		// Draw the paper inside the folder
		if (!isSelected) {
			ctx.fillStyle = paperCol;
			ctx.beginPath();
			ctx.moveTo(x+10, y+2);
			ctx.lineTo(x+10, y+40);
			ctx.lineTo(x+35, y+40);
			ctx.lineTo(x+35, y+2);
			ctx.fill();
		} else {
			ctx.fillStyle = paperCol;
			ctx.beginPath();
			ctx.moveTo(x+10, y-5);
			ctx.lineTo(x+10, y+40);
			ctx.lineTo(x+35, y+40);
			ctx.lineTo(x+35, y-5);
			ctx.fill();
		}

		// Draw the front bit of the folder
		if (!isSelected) {
			ctx.fillStyle = frontCol;
			ctx.beginPath();
			ctx.moveTo(x+05, y+15);
			ctx.lineTo(x, y+40);
			ctx.lineTo(x+40, y+40);
			ctx.lineTo(x+50, y+15);
			ctx.fill();
		} else {
			ctx.fillStyle = frontCol;
			ctx.beginPath();
			ctx.moveTo(x+05, y+15);
			ctx.lineTo(x, y+40);
			ctx.lineTo(x+40, y+40);
			ctx.lineTo(x+50, y+15);
			ctx.fill();
		}

	// If it's the save/download icon
	} else if (letter == "save") {

		// To save adding this everywhere
		x = x-gateSizeFixed/2;
		y = y-gateSizeFixed/2;

		// Main plastic bit
		ctx.fillStyle = "#00bbd4";
		ctx.beginPath();
		ctx.moveTo(x+5, y);
		ctx.lineTo(x+5, y+40);
		ctx.lineTo(x+40, y+40);
		ctx.lineTo(x+40, y+5);
		ctx.lineTo(x+35, y);
		ctx.fill();

		// Top white bit
		ctx.fillStyle = "#ffffff";
		ctx.beginPath();
		ctx.moveTo(x+10, y);
		ctx.lineTo(x+10, y+10);
		ctx.lineTo(x+30, y+10);
		ctx.lineTo(x+30, y);
		ctx.fill();

		// Black bit inside top white bit
		if (!isSelected) {
			ctx.fillStyle = "#000000";
			ctx.beginPath();
			ctx.moveTo(x+22, y);
			ctx.lineTo(x+22, y+10);
			ctx.lineTo(x+30, y+10);
			ctx.lineTo(x+30, y);
			ctx.fill();
		} else {
			ctx.fillStyle = "#000000";
			ctx.beginPath();
			ctx.moveTo(x+10, y);
			ctx.lineTo(x+10, y+10);
			ctx.lineTo(x+18, y+10);
			ctx.lineTo(x+18, y);
			ctx.fill();
		}
		
		// Bottom white bit
		ctx.fillStyle = "#ffffff";
		ctx.beginPath();
		ctx.moveTo(x+10, y+20);
		ctx.lineTo(x+10, y+40);
		ctx.lineTo(x+35, y+40);
		ctx.lineTo(x+35, y+20);
		ctx.fill();

	// Left arrow 
	} else if (letter == "left") {

		// Draw the arrow
		if (!isSelected) {
			ctx.fillStyle = "#555555";
		} else {
			ctx.fillStyle = "#888888";
		}
		ctx.beginPath();
		ctx.moveTo(x+gateSizeFixed/3, y-gateSizeFixed/3);
		ctx.lineTo(x+gateSizeFixed/3, y+gateSizeFixed/3);
		ctx.lineTo(x, y);
		ctx.fill();

	// Right arrow 
	} else if (letter == "right") {

		// Draw the arrow
		if (!isSelected) {
			ctx.fillStyle = "#555555";
		} else {
			ctx.fillStyle = "#888888";
		}
		ctx.beginPath();
		ctx.moveTo(x-gateSizeFixed/3, y-gateSizeFixed/3);
		ctx.lineTo(x-gateSizeFixed/3, y+gateSizeFixed/3);
		ctx.lineTo(x, y);
		ctx.fill();

	// If drawing the delete icon 
	} else if (letter == "delete") {

		// To save adding this everywhere
		x = x-gateSizeFixed/2;

		// Colours
		ctx.fillStyle = "#55555588";
		ctx.strokeStyle = "#55555588";

		// Bottom
		ctx.beginPath();
		ctx.moveTo(x, y+10);
		ctx.lineTo(x+5, y+40);
		ctx.lineTo(x+25, y+40);
		ctx.lineTo(x+30, y+10);
		ctx.fill();

		// Lid
		ctx.beginPath();
		ctx.moveTo(x, y+7);
		ctx.lineTo(x+5, y);
		ctx.lineTo(x+25, y);
		ctx.lineTo(x+30, y+7);
		ctx.fill();

		// Lid handle 
		ctx.lineWidth = 3;
		ctx.beginPath();
		ctx.arc(x+15, y, 5, Math.PI, 0, false);
		ctx.stroke();

	// If it's a standard gate
	} else {

		// If it's a H
		if (letter == "H") {
			if (!isSelected) {
				ctx.fillStyle = "#e3970b";
			} else {
				ctx.fillStyle = "#bf7e04";
			}

		// If it's something else
		} else {
			if (!isSelected) {
				ctx.fillStyle = "#37abc8";
			} else {
				ctx.fillStyle = "#298399";
			}
		}

		// If allowed to scale with zoom 
		if (!fixedSize) {

			// Draw the box
			ctx.fillRect(x-gateSize/2, y-gateSize/2, gateSize, gateSize+gridY*(size-1));
			svgRect(x-gateSize/2, y-gateSize/2, gateSize, gateSize+gridY*(size-1), ctx.fillStyle);

			// Draw the letter 
			if (letter != "I") {
				ctx.font = (fontSize*0.9) + "px Arial";
				ctx.fillStyle = "#ffffff";
				ctx.fillText(letter, gridX*0.25+x-gateSize/2, gridY*0.58+y-gateSize/2);
				svgText(letter, gridX*0.25+x-gateSize/2, gridY*0.58+y-gateSize/2, (fontSize*0.9), ctx.measureText(letter).width, ctx.fillStyle);
			} else {
				ctx.font = (fontSize*0.9) + "px Serif";
				ctx.fillStyle = "#ffffff";
				ctx.fillText(letter, gridX*0.32+x-gateSize/2, gridY*0.60+y-gateSize/2);
				svgText(letter, gridX*0.32+x-gateSize/2, gridY*0.60+y-gateSize/2, (fontSize*0.9), ctx.measureText(letter).width, ctx.fillStyle);
			}

		// If part of the toolbar or something not scalable
		} else {
			
			// Draw the box
			ctx.fillRect(x-gateSizeFixed/2, y-gateSizeFixed/2, gateSizeFixed, gateSizeFixed+gridY*(size-1));

			// Draw the letter
			if (letter != "I") {
				ctx.font = "30px Arial";
				ctx.fillStyle = "#ffffff";
				ctx.fillText(letter, 15+x-gateSizeFixed/2, 35+y-gateSizeFixed/2);
			} else {
				ctx.font = "30px Serif";
				ctx.fillStyle = "#ffffff";
				ctx.fillText(letter, 19+x-gateSizeFixed/2, 35+y-gateSizeFixed/2);
			}

		}


	}

}

// Called whenever something is changed
function redraw(t=0) {

	// Screen is able to update, thus probably not in the prompt 
	inPrompt = false;

	// Reset the svg vars
	svgString = "";
	svgMinX = 99999;
	svgMaxX = -99999;
	svgMinY = 99999;
	svgMaxY = -99999;

	// Ensure it's scaled to the window 
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	// Draw grid lines
	if (drawGrid) {
		ctx.lineWidth = fontSize/35;
		ctx.strokeStyle = "#aaaaaa";
		ctx.beginPath();
		for (var x=offsetX%gridX; x<ctx.canvas.width; x+=gridX) {
			ctx.moveTo(x-(gridX/2)+(gateSize/2), 0);
			ctx.lineTo(x-(gridX/2)+(gateSize/2), ctx.canvas.height);
		}
		for (var y=offsetY%gridY; y<ctx.canvas.height; y+=gridY) {
			ctx.moveTo(0, y-(gridY/2)+(gateSize/2));
			ctx.lineTo(ctx.canvas.width, y-(gridY/2)+(gateSize/2));
		}
		ctx.stroke();
	}

	// Onlt recalc recs if needed
	if (circuitUpdates > 0 || recalcRecs) {

		// Reset things
		qubitsWithGates = [];
		lineStartEnds = [];
		recalcRecs = false;

		// Find qubit line rectangles needed ([minX,maxX,minY,maxY])
		for (var i=gateOptions; i<gates.length; i++) {

			// Only look at non-function gates first
			if (gates[i]["letter"] != "sub" && gates[i]["letter"].substring(0,4) != "text" && gates[i]["letter"] != "go") {

				// Gate info caches
				var gateX = gates[i]["x"];
				var gateY = gates[i]["y"];
				var size = gates[i]["size"]-1;

				// If it's a function gate inside any other function 
				if (gates[i]["letter"] == "fun") {

					// Assume it's fine
					gates[i]["rec"] = false;

					// Assume controls are fine too
					for (var k=0; k<gates[i]["attached"].length; k++) {
						var conInd = fromID(gates[i]["attached"][k]);
						gates[conInd]["rec"] = false;
					}

					// Check all known function locations
					for (var j=0; j<funcStartEnds.length; j++) {

						// If recursive, don't expand
						if (gateY+size >= funcStartEnds[j][2]-2 && gateY <= funcStartEnds[j][3]+2) {
							gates[i]["rec"] = true;
						}

						// Also check controls 
						for (var k=0; k<gates[i]["attached"].length; k++) {
							var conInd = fromID(gates[i]["attached"][k]);
							if (gates[conInd]["y"] >= funcStartEnds[j][2]-2 && gates[conInd]["y"] <= funcStartEnds[j][3]+2) {
								gates[i]["rec"] = true;
								gates[conInd]["rec"] = true;
							}

						}

					}

				}
				
				// Don't deal with it if it's trying to recurse
				if (gates[i]["rec"] === true) {
					continue;
				}

				// Keep track of the number of gates on each qubit
				for (var j=0; j<size+1; j++) {
					if (qubitsWithGates.indexOf(gateY+j) < 0) {
						qubitsWithGates.push(gateY+j);
					}
				}

				// Check if this gate is in an existing rectangle 
				var inRect = [];
				for (var j=0; j<lineStartEnds.length; j++) {

					// If the gate itself is in the rect
					if (gateY <= lineStartEnds[j][3]+1 && gateY+size >= lineStartEnds[j][2]-1) {
						inRect.push(j);
					}
					
					// If it's a control, check its main gate
					if (gates[i]["letter"] == "controlFilled" || gates[i]["letter"] == "controlUnfilled") {
						ogInd = fromID(gates[i]["og"]);
						if (gates[ogInd]["y"] <= lineStartEnds[j][3]+1 && gates[ogInd]["y"] >= lineStartEnds[j][2]-1) {
							inRect.push(j);
						}
					}

					// If any of its controls are 
					for (var k=0; k<gates[i]["attached"].length; k++) {
						controlInd = fromID(gates[i]["attached"][k]);
						if ((gates[controlInd]["y"] <= lineStartEnds[j][3]+1 && gates[controlInd]["y"] >= lineStartEnds[j][2]-1) || (gates[controlInd]["y"] >= lineStartEnds[j][3]+1 && gateY <= lineStartEnds[j][2]-1) || (gates[controlInd]["y"] <= lineStartEnds[j][2]-1 && gateY >= lineStartEnds[j][3]+1)) {
							inRect.push(j);
						}
					}

				}

				// If connecting multiple rectangles 
				if (inRect.length >= 1) {

					// Start with a slightly expanded rect
					var mergedRect = [gateX-1, gateX+1, gateY, gateY+size, -1];

					// Combine rects
					for (var k=0; k<inRect.length; k++) {
						
						// Update the mins/maxs
						if (lineStartEnds[inRect[k]][0] < mergedRect[0]) {
							mergedRect[0] = lineStartEnds[inRect[k]][0];
						} 
						if (lineStartEnds[inRect[k]][1] > mergedRect[1]) {
							mergedRect[1] = lineStartEnds[inRect[k]][1];
						}
						if (lineStartEnds[inRect[k]][2] < mergedRect[2]) {
							mergedRect[2] = lineStartEnds[inRect[k]][2];
						}
						if (lineStartEnds[inRect[k]][3] > mergedRect[3]) {
							mergedRect[3] = lineStartEnds[inRect[k]][3];
						}
						if (lineStartEnds[inRect[k]][4] != -1) {
							mergedRect[4] = lineStartEnds[inRect[k]][4];
						}

					}

					// Remove the old ones 
					var newList = []
					for (var k=0; k<lineStartEnds.length; k++) {
						if (inRect.indexOf(k) < 0) {
							newList.push(lineStartEnds[k].slice());
						}
					}
					newList.push(mergedRect.slice());
					lineStartEnds = newList.slice();

				// Otherwise add a new rectangle
				} else if (gates[i]["letter"] != "sub") {

					// Add the new rect
					lineStartEnds.push([gateX-1, gateX+1, gateY, gateY+size, -1]);

					// This gate is creating a new rect, thus isn't recursing
					if (gates[i]["letter"] == "fun") {
						gates[i]["rec"] = false;
					}

				}

			}

		}

		// Now check again, but for function gates
		funcStartEnds = [];
		for (var i=gateOptions; i<gates.length; i++) {

			// If it's a function gate
			if (gates[i]["letter"] == "sub") {

				// For consistency with prev section
				gateX = gates[i]["x"];
				gateY = gates[i]["y"];

				// Loop over the rects 
				for (var j=0; j<lineStartEnds.length; j++) {

					// See if this rect should be a function  
					if (gateY >= lineStartEnds[j][2]-1 && gateY <= lineStartEnds[j][3]+1 && gateX == lineStartEnds[j][0]-1) {
						lineStartEnds[j][4] = gates[i]["funID"];
						funcStartEnds.push(lineStartEnds[j].slice());
						break;
					}

				}

			}

		}

	}

	// Draw each qubit grid
	ctx.lineWidth = fontSize/7;
	ctx.strokeStyle = "#aaaaaa";
	ctx.beginPath();
	for (var i=0; i<lineStartEnds.length; i++) {
		for (var y=lineStartEnds[i][2]; y<=lineStartEnds[i][3]; y++) {
			if (qubitsWithGates.indexOf(y) >= 0) {
				ctx.moveTo(floor(lineStartEnds[i][0]*gridX+gateSize/2+offsetX), floor(offsetY+y*gridY+gateSize/2));
				ctx.lineTo(floor(lineStartEnds[i][1]*gridX+gateSize/2+offsetX), floor(offsetY+y*gridY+gateSize/2));
				svgLine(lineStartEnds[i][0]*gridX+gateSize/2+offsetX, offsetY+y*gridY+gateSize/2, lineStartEnds[i][1]*gridX+gateSize/2+offsetX, offsetY+y*gridY+gateSize/2, ctx.strokeStyle, fontSize/7);
			}
		}
	}
	ctx.stroke();

	// Do the same for the special function outlines
	ctx.lineWidth = fontSize/3.5;
	ctx.strokeStyle = "#16a300";
	ctx.beginPath();
	for (var i=0; i<lineStartEnds.length; i++) {
		if (lineStartEnds[i][4] != -1) {
			ctx.moveTo((lineStartEnds[i][0]+1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][2]-1)*gridY+gateSize/2);
			ctx.lineTo((lineStartEnds[i][0]-1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][2]-1)*gridY+gateSize/2);
			ctx.lineTo((lineStartEnds[i][0]-1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][3]+1)*gridY+gateSize/2);
			ctx.lineTo((lineStartEnds[i][1]+1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][3]+1)*gridY+gateSize/2);
			ctx.lineTo((lineStartEnds[i][1]+1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][2]-1)*gridY+gateSize/2);
			ctx.lineTo((lineStartEnds[i][0]+1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][2]-1)*gridY+gateSize/2);
			svgLine((lineStartEnds[i][0]-1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][2]-1)*gridY+gateSize/2, (lineStartEnds[i][1]+1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][2]-1)*gridY+gateSize/2, ctx.strokeStyle, ctx.lineWidth);
			svgLine((lineStartEnds[i][0]-1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][2]-1)*gridY+gateSize/2, (lineStartEnds[i][0]-1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][3]+1)*gridY+gateSize/2+3, ctx.strokeStyle, ctx.lineWidth);
			svgLine((lineStartEnds[i][0]-1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][3]+1)*gridY+gateSize/2, (lineStartEnds[i][1]+1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][3]+1)*gridY+gateSize/2, ctx.strokeStyle, ctx.lineWidth);
			svgLine((lineStartEnds[i][1]+1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][3]+1)*gridY+gateSize/2+3, (lineStartEnds[i][1]+1)*gridX+gateSize/2+offsetX, offsetY+(lineStartEnds[i][2]-1)*gridY+gateSize/2-3, ctx.strokeStyle, ctx.lineWidth);
		}
	}
	ctx.stroke();

	// Draw the control lines
	for (var i=gateOptions; i<gates.length; i++) {

		// For things that aren't swap gates
		if (gates[i]["letter"].substr(0,4) != "swap") {
			ctx.lineWidth = fontSize/7;
			ctx.strokeStyle = "#555555";
			ctx.beginPath();
			for (var j=0; j<gates[i]["attached"].length; j++) {
				ctx.moveTo(gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2);
				ctx.lineTo(gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[fromID(gates[i]["attached"][j])]["y"]*gridY+gateSize/2);
				svgLine(gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[fromID(gates[i]["attached"][j])]["y"]*gridY+gateSize/2, ctx.strokeStyle, fontSize/7);
			}
			ctx.stroke();

		// For swap gates 
		} else {

			// The line between the swaps (only need to draw once)
			ctx.lineWidth = fontSize/7;
			ctx.strokeStyle = "#aaaaaa";
			ctx.beginPath();
			if (gates[i]["letter"] == "swaptop") {
				ctx.moveTo(gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2);
				ctx.lineTo(gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[fromID(gates[i]["attached"][0])]["y"]*gridY+gateSize/2);
				svgLine(gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[fromID(gates[i]["attached"][0])]["y"]*gridY+gateSize/2, ctx.strokeStyle, fontSize/7);
			}
			ctx.stroke();

			// The lines to any actual controls
			ctx.strokeStyle = "#555555";
			ctx.beginPath();
			for (var j=1; j<gates[i]["attached"].length; j++) {
				ctx.moveTo(gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY);
				ctx.lineTo(gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[fromID(gates[i]["attached"][j])]["y"]*gridY+gateSize/2);
			}
			ctx.stroke();

		}

	}

	// Draw the gates
	for (var i=gateOptions; i<gates.length; i++) {
		isSel = (i == hover) || (selectionArray.indexOf(i) >= 0);

		// If it's a function definition 
		if (gates[i]["letter"] == "sub") {

			// Draw it
			drawGate(gates[i]["letter"]+gates[i]["funID"], gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, 1);

		// If it's a function call 
		} else if (gates[i]["letter"] == "fun") {

			// If there's some sort of error, recursion or otherwise 
			rectInd = indFromFunID(gates[i]["funID"]);
			if (gates[i]["rec"] || rectInd < 0) {
				drawGate("?", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);

			// Otherwise draw normally
			} else {
				gates[i]["size"] = lineStartEnds[rectInd][3]-lineStartEnds[rectInd][2]+1;
				drawGate(gates[i]["letter"]+gates[i]["funID"], gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			}

		// If it's the (originally) top part a swap gate
		} else if (gates[i]["letter"] == "swaptop") {

			// If lower than the bottom part, swap
			var otherInd = fromID(gates[i]["attached"][0]);
			if (gates[i]["y"] > gates[otherInd]["y"]) {
				drawGate("swapbottom", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			} else {
				drawGate("swaptop", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			}

		// If it's the (originally) bottom part a swap gate
		} else if (gates[i]["letter"] == "swapbottom") {

			// If lower than the bottom part, swap
			var otherInd = fromID(gates[i]["attached"][0]);
			if (gates[i]["y"] < gates[otherInd]["y"]) {
				drawGate("swaptop", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			} else {
				drawGate("swapbottom", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			}

		// If it's a normal gate
		} else if (gates[i]["letter"].substring(0,4) != "text") {

			// Draw it
			drawGate(gates[i]["letter"], gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);

		}
	}

	// Only when the circuit has changed
	if (circuitUpdates > 0) {

		// Reset random index
		randInd = 0;

		// Reset the cached unitaries
		funcUnitaries = [];

		// For each independent section of circuit
		for (var i=0; i<lineStartEnds.length; i++) {

			// For functions
			if (lineStartEnds[i][4] != -1) {

				// Get the inputs 
				inputs[i] = [[100, [1, 0], ""]]
				for (var j=0; j<1+lineStartEnds[i][3]-lineStartEnds[i][2]; j++) {
					inputs[i][0][2] += "0";
				}

				// If we want the whole unitary
				if (simMethod == "Unitary") {
					results[i] = getUnitary(gates, lineStartEnds[i]);
					funcUnitaries[lineStartEnds[i][4]] = results[i];

				// Even if we're not gonna display it, need to cache
				} else if (simMethod == "Statevector") {
					funcUnitaries[lineStartEnds[i][4]] = getUnitary(gates, lineStartEnds[i]);

				}

			}

		}

		// For each independent section of circuit
		for (var i=0; i<lineStartEnds.length; i++) {

			// If not a function
			if (lineStartEnds[i][4] == -1) {

				// Get the inputs 
				inputs[i] = [[100, [1, 0], ""]]
				for (var j=0; j<1+lineStartEnds[i][3]-lineStartEnds[i][2]; j++) {
					inputs[i][0][2] += "0";
				}

				// If doing a measurement-based sim
				if (simMethod == "Measurements") {
					results[i] = simulateCircuit(inputs[i][0], gates, lineStartEnds[i], numRepeats, 0);

				// If we want the whole unitary
				} else if (simMethod == "Unitary") {
					results[i] = getUnitary(gates, lineStartEnds[i]);

				// If we want the whole unitary
				} else if (simMethod == "Statevector") {
					results[i] = getStatevector(gates, lineStartEnds[i]);

				}

			}

		}

		// If not empty
		if (gates.length > gateOptions) {

			// Convert gate list to URL-ready QASM
			var newURL = toQASM(qasmVersion);
			var encoded = encodeURIComponent(newURL);

			// If in view mode, stay that way
			if (!canEdit) {
				encoded = "view" + encoded;
			}

			// Save the sim method
			if (simMethod == "Unitary") {
				encoded = "unitary" + encoded;
			}
			if (simMethod == "Measurements") {
				encoded = "measurements" + encoded;
			}
			if (simMethod == "Statevector") {
				encoded = "statevector" + encoded;
			}

			// Update URL 
			history.replaceState(null, null, document.location.pathname + '#' + encoded);

			// If not told to not add to the history
			if (!noHistory) {

				// Add to history
				qasmHistory.push(encoded);
				if (qasmHistory.length > maxHistory) {
					qasmHistory.splice(0, qasmHistory.length-maxHistory);
				}
				historyIndex = qasmHistory.length-1;

			}

		} else {

			// Reset URL 
			history.replaceState(null, null, document.location.pathname);

		}

		// Circuit no longer needs re-simulating
		circuitUpdates -= 1;

		// If all the updates are finished, next update should add to the history
		if (circuitUpdates == 0) {
			noHistory = false;
		}

	}

	// Only if not dragging
	if (selected < 0) {

		// For each independent section of circuit
		for (var i=0; i<Math.min(inputs.length, lineStartEnds.length); i++) {

			// If not a function
			if (lineStartEnds[i][4] == -1) {

				// If doing a measurement-based sim
				if (simMethod == "Measurements") {

					// Render the inputs
					renderState(ctx, inputs[i], lineStartEnds[i][0]-1, lineStartEnds[i][2], qubitsWithGates, true);
					
					// Render the outputs
					renderState(ctx, results[i], lineStartEnds[i][1]+1, lineStartEnds[i][2], qubitsWithGates, false);

				// If we're rendering the whole unitary
				} else if (simMethod == "Unitary") {
					renderUnitary(ctx, results[i], lineStartEnds[i][1]+1, Math.floor((lineStartEnds[i][2]+lineStartEnds[i][3])/2), qubitsWithGates, false);

				// If we're just rendering the final statevector
				} else if (simMethod == "Statevector") {

					var zeroInput = [[], []];
					for (var k=0; k<results[i][0].length; k++) {
						zeroInput[0].push(0);
						zeroInput[1].push(0);
					}
					zeroInput[0][0] = 1;

					// Inputs
					renderStatevector(ctx, zeroInput, lineStartEnds[i][0]-1, lineStartEnds[i][2], qubitsWithGates, false);

					// Outputs
					renderStatevector(ctx, results[i], lineStartEnds[i][1]+1, lineStartEnds[i][2], qubitsWithGates, false);

				}

			// For functions
			} else {

				// If we're rendering the whole unitary
				if (simMethod == "Unitary") {
					renderUnitary(ctx, results[i], lineStartEnds[i][1]+2, Math.floor((lineStartEnds[i][2]+lineStartEnds[i][3])/2), qubitsWithGates, false);
				}

			}

		}

	}

	// Draw the text objects 
	for (var i=gateOptions; i<gates.length; i++) {
		if (gates[i]["letter"].substring(0,4) == "text") {
			isSel = (i == hover) || (selectionArray.indexOf(i) >= 0);
			drawGate(gates[i]["letter"], gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
		}
	}

	// Draw the toolbar if allowed
	if (canEdit) {

		// Toolbar outline 
		ctx.fillStyle = "#dddddd";
		roundRect(ctx, toolbarOffsetX, 10, toolbarWidth, toolbarHeight, 20, true, false);
		
		// Draw the toolbar gates
		for (var i=0; i<gateOptions; i++) {
			if (i==0 || i>toolbarGates.length || (i>toolbarIndex && i<1+toolbarIndex+numGatesToShow)) {
				drawGate(gates[i]["letter"], gates[i]["x"]*gridXFixed+gateSizeFixed/2, gates[i]["y"]*gridYFixed+gateSizeFixed/2, i==hover, gates[i]["size"], true);
			}
		}

		// If dragging a gate, change the toolbar
		if (showDelete) {

			// Fade everything
			ctx.fillStyle = "#aaaaaa55";
			roundRect(ctx, toolbarOffsetX, 10, toolbarWidth, toolbarHeight, 20, true, false);

			// Draw a delete icon 
			drawGate("delete", toolbarOffsetX+toolbarWidth/2, 30, false, 1);

		}

	}

	// Draw the selected gate on top
	if (selected >= 0) {

		// To allow copy/pasting from the gate drawing section above
		i = selected;

		// If it's the (originally) top part a swap gate
		if (gates[i]["letter"] == "swaptop") {

			// If lower than the bottom part, swap
			var otherInd = fromID(gates[i]["attached"][0]);
			if (gates[i]["y"] > gates[otherInd]["y"]) {
				drawGate("swapbottom", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			} else {
				drawGate("swaptop", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			}

		// If it's the (originally) bottom part a swap gate
		} else if (gates[i]["letter"] == "swapbottom") {

			// If lower than the bottom part, swap
			var otherInd = fromID(gates[i]["attached"][0]);
			if (gates[i]["y"] < gates[otherInd]["y"]) {
				drawGate("swaptop", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			} else {
				drawGate("swapbottom", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, isSel, gates[i]["size"]);
			}

		// If it's a normal gate
		} else if (gates[i]["letter"] != "fun") {

			// Draw it
			drawGate(gates[i]["letter"], gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, true, gates[i]["size"]);

		// If it's a function call 
		} else {

			// Draw it normally
			if (gates[i]["rec"]) {
				drawGate(gates[i]["letter"], gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, true, gates[i]["size"]);
			} else {
				drawGate("?", gates[i]["x"]*gridX+gateSize/2+offsetX, offsetY+gates[i]["y"]*gridY+gateSize/2, true, gates[i]["size"]);
			}

		}

	}

	// If box selecting, draw the box
	if (selected == -6) {
		ctx.fillStyle = "#aaaaaa55";
		ctx.fillRect(selectStartX, selectStartY, selectEndX-selectStartX, selectEndY-selectStartY);
	}

	// If help window open 
	if (helpOpen) {

		// If not on mobile 
		if (onMobile == 0) {

			var helpWidth = 500;
			var helpHeight = 300;
			var helpLeft = window.innerWidth / 2 - helpWidth / 2;
			var helpTop = window.innerHeight / 2 - helpHeight / 2;

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, helpLeft, helpTop, helpWidth, helpHeight, 20, true, false);

			// Logo section
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, helpLeft+180, helpTop-90, 120, 180, 10, true, false);
			drawGate("logo", helpLeft+240, helpTop-35, false, 2.6, true);

			// Draw the title inner rect
			ctx.fillStyle = "#eeeeee";
			roundRect(ctx, helpLeft+30, helpTop+30, helpWidth-60, 80, 10, true, false);

			// Draw the title text
			ctx.font = "38px Arial";
			ctx.fillStyle = "#555555";
			ctx.fillText("Welcome to Agate!", helpLeft+85, helpTop+85);

			// Draw the intro text 
			ctx.fillStyle = "#555555";
			ctx.font = "23px arial";
			ctx.fillText("Agate is a quantum circuit designer", helpLeft+60, helpTop+155);
			ctx.fillText("and simulator by Lumorti", helpLeft+60, helpTop+185);
			ctx.fillText(tips[tipInd][1], helpLeft+60, helpTop+230);
			ctx.fillText(tips[tipInd][2], helpLeft+60, helpTop+260);
			drawGate(tips[tipInd][0], helpLeft+425, helpTop+230, false, 1, true);

		// If on mobile (vertical)
		} else if (onMobile == 1) {

			var helpWidth = 300;
			var helpHeight = 260;
			var helpLeft = window.innerWidth / 2 - helpWidth / 2;
			var helpTop = Math.max(toolbarHeight+140, window.innerHeight / 1.6 - helpHeight / 2);

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, helpLeft, helpTop, helpWidth, helpHeight, 20, true, false);

			// Logo section
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, helpLeft+90, helpTop-90, 120, 180, 10, true, false);
			drawGate("logo", helpLeft+150, helpTop-35, false, 3, true);

			// Draw the title inner rect
			ctx.fillStyle = "#eeeeee";
			roundRect(ctx, helpLeft+30, helpTop+30, helpWidth-60, 80, 10, true, false);

			// Draw the title text
			ctx.font = "38px Arial";
			ctx.fillStyle = "#555555";
			ctx.fillText("Welcome!", helpLeft+65, helpTop+85);

			// Draw the intro text 
			ctx.fillStyle = "#555555";
			ctx.font = "23px Arial";
			ctx.fillText("If you're new, load the", helpLeft+40, helpTop+155);
			ctx.fillText("tutorial using the open", helpLeft+40, helpTop+185);
			ctx.fillText("icon at the top", helpLeft+40, helpTop+215);

		// If on mobile (horizontal) 
		} else if (onMobile == 2) {

			var helpWidth = 440;
			var helpHeight = 220;
			var helpLeft = window.innerWidth / 2 - helpWidth / 2;
			var helpTop = window.innerHeight / 1.7 - helpHeight / 2;

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, helpLeft, helpTop, helpWidth, helpHeight, 20, true, false);

			// Draw the title inner rect
			ctx.fillStyle = "#eeeeee";
			roundRect(ctx, helpLeft+30, helpTop+30, helpWidth-60, 80, 10, true, false);
			
			// Draw the title text
			ctx.font = "38px Arial";
			ctx.fillStyle = "#555555";
			ctx.fillText("Welcome to Agate!", helpLeft+60, helpTop+85);

			// Draw the intro text 
			ctx.fillStyle = "#555555";
			ctx.font = "23px Arial";
			ctx.fillText("If you're new, load the tutorial", helpLeft+70, helpTop+155);
			ctx.fillText("using the open icon at the top", helpLeft+70, helpTop+185);

		}

	}

	// If the load window is open 
	if (loadOpen) {

		// Hide everything else
		outputBox.style.display = "none";
		fpsBox.style.display = "none";
		simBox.style.display = "none";
		repeatsBox.style.display = "none";
		gridBox.style.display = "none";

		// If mobile (vertical)
		if (onMobile == 1) {

			// Settings to be updated here in case of window resize
			var loadWidth = 300;
			var loadHeight = 210;
			var loadLeft = window.innerWidth / 2 - loadWidth / 2;
			var loadTop = window.innerHeight / 2 - loadHeight / 2;

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, loadLeft, loadTop, loadWidth, loadHeight, 20, true, false);

			// Draw the help text
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Select a file type or preset", loadLeft+35, loadTop+45);

			// Update the preset selection box 
			inputBox.style.top = (loadTop+70) + "px";
			inputBox.style.left = (loadLeft+30) + "px";
			inputBox.style.width = (loadWidth-60) + "px";
			inputBox.style.display = "block";
			
			// Draw the second load button
			openDims = [loadLeft+120, loadLeft+180, loadTop+130, loadTop+190];
			drawGate("open", loadLeft+150, loadTop+160, openHover, 1);

		} else {

			// Settings to be updated here in case of window resize
			var loadWidth = 390;
			var loadHeight = 160;
			var loadLeft = window.innerWidth / 2 - loadWidth / 2;
			var loadTop = window.innerHeight / 2 - loadHeight / 2;

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, loadLeft, loadTop, loadWidth, loadHeight, 20, true, false);

			// Draw the help text
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Select a file type or preset to load", loadLeft+40, loadTop+45);

			// Update the preset selection box 
			inputBox.style.top = (loadTop+70) + "px";
			inputBox.style.left = (loadLeft+30) + "px";
			inputBox.style.width = (loadWidth-140) + "px";
			inputBox.style.display = "block";
			
			// Draw the second load button
			openDims = [loadLeft+300, loadLeft+360, loadTop+63, loadTop+123];
			drawGate("open", loadLeft+330, loadTop+93, openHover, 1);

		}

	// If the save window is open 
	} else if (saveOpen) {

		// Hide everything else
		inputBox.style.display = "none";
		fpsBox.style.display = "none";
		simBox.style.display = "none";
		repeatsBox.style.display = "none";
		gridBox.style.display = "none";

		// If mobile (vertical)
		if (onMobile == 1) {

			// Settings to be updated here in case of window resize
			var saveWidth = 300;
			var saveHeight = 210;
			var saveLeft = window.innerWidth / 2 - saveWidth / 2;
			var saveTop = window.innerHeight / 2 - saveHeight / 2;

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, saveLeft, saveTop, saveWidth, saveHeight, 20, true, false);

			// Draw the help text
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Select a file type", saveLeft+70, saveTop+45);

			// Update the preset selection box 
			outputBox.style.top = (saveTop+70) + "px";
			outputBox.style.left = (saveLeft+30) + "px";
			outputBox.style.width = (saveWidth-60) + "px";
			outputBox.style.display = "block";
			
			// Draw the second save button
			saveDims = [saveLeft+120, saveLeft+180, saveTop+140, saveTop+200];
			drawGate("save", saveLeft+150, saveTop+170, saveHover, 1);

		} else {

			// Settings to be updated here in case of window resize
			var saveWidth = 350;
			var saveHeight = 160;
			var saveLeft = window.innerWidth / 2 - saveWidth / 2;
			var saveTop = window.innerHeight / 2 - saveHeight / 2;

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, saveLeft, saveTop, saveWidth, saveHeight, 20, true, false);

			// Draw the help text
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Select a file type to save as", saveLeft+50, saveTop+45);

			// Update the preset selection box 
			outputBox.style.top = (saveTop+70) + "px";
			outputBox.style.left = (saveLeft+30) + "px";
			outputBox.style.width = (saveWidth-120) + "px";
			outputBox.style.display = "block";
			
			// Draw the second save button
			saveDims = [saveLeft+275, saveLeft+335, saveTop+73, saveTop+133];
			drawGate("save", saveLeft+305, saveTop+103, saveHeight, 1);

		}

	// If the settings window is open
	} else if (settingsOpen) {

		// Hide everything else
		inputBox.style.display = "none";
		outputBox.style.display = "none";

		// If mobile (vertical)
		if (onMobile == 1) {

			// Settings to be updated here in case of window resize
			var optionsWidth = 390;
			var optionsHeight = 250;
			var optionsLeft = window.innerWidth / 2 - optionsWidth / 2;
			var optionsTop = window.innerHeight / 2 - optionsHeight / 2;

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, optionsLeft, optionsTop, optionsWidth, optionsHeight, 20, true, false);

			// FPS toggle
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Show FPS?", optionsLeft+47, optionsTop+55);
			fpsBox.style.top = (optionsTop+35) + "px";
			fpsBox.style.left = (optionsLeft+170) + "px";
			fpsBox.style.display = "block";

			// Grid toggle
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Show grid?", optionsLeft+50, optionsTop+105);
			gridBox.style.top = (optionsTop+85) + "px";
			gridBox.style.left = (optionsLeft+170) + "px";
			gridBox.style.display = "block";

			// Sim method dropdown
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Sim method:", optionsLeft+40, optionsTop+160);
			simBox.style.top = (optionsTop+130) + "px";
			simBox.style.left = (optionsLeft+170) + "px";
			simBox.style.width = (optionsWidth-190) + "px";
			simBox.style.display = "block";

			// Repeats input
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Num shots:", optionsLeft+50, optionsTop+215);
			if (simMethod == "Measurements") {
				repeatsBox.disabled = false;
			} else {
				repeatsBox.disabled = true;
			}
			repeatsBox.style.top = (optionsTop+185) + "px";
			repeatsBox.style.left = (optionsLeft+170) + "px";
			repeatsBox.style.width = (optionsWidth-190) + "px";
			repeatsBox.style.display = "block";

		} else {

			// Settings to be updated here in case of window resize
			var optionsWidth = 390;
			var optionsHeight = 250;
			var optionsLeft = window.innerWidth / 2 - optionsWidth / 2;
			var optionsTop = window.innerHeight / 2 - optionsHeight / 2;

			// Draw the outline
			ctx.fillStyle = "#dddddd";
			roundRect(ctx, optionsLeft, optionsTop, optionsWidth, optionsHeight, 20, true, false);

			// FPS toggle
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Show FPS?", optionsLeft+47, optionsTop+55);
			fpsBox.style.top = (optionsTop+35) + "px";
			fpsBox.style.left = (optionsLeft+170) + "px";
			fpsBox.style.display = "block";

			// Grid toggle
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Show grid?", optionsLeft+50, optionsTop+105);
			gridBox.style.top = (optionsTop+85) + "px";
			gridBox.style.left = (optionsLeft+170) + "px";
			gridBox.style.display = "block";

			// Sim method dropdown
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Sim method:", optionsLeft+40, optionsTop+160);
			simBox.style.top = (optionsTop+130) + "px";
			simBox.style.left = (optionsLeft+170) + "px";
			simBox.style.width = (optionsWidth-190) + "px";
			simBox.style.display = "block";

			// Repeats input
			ctx.fillStyle = "#000000";
			ctx.font = "20px Arial";
			ctx.fillText("Num shots:", optionsLeft+50, optionsTop+215);
			if (simMethod == "Measurements") {
				repeatsBox.disabled = false;
			} else {
				repeatsBox.disabled = true;
			}
			repeatsBox.style.top = (optionsTop+185) + "px";
			repeatsBox.style.left = (optionsLeft+170) + "px";
			repeatsBox.style.width = (optionsWidth-190) + "px";
			repeatsBox.style.display = "block";

		}

	// Otherwise hide everything
	} else {
		inputBox.style.display = "none";
		outputBox.style.display = "none";
		fpsBox.style.display = "none";
		simBox.style.display = "none";
		repeatsBox.style.display = "none";
		gridBox.style.display = "none";

	}

	// Draw any debug text, if applicable
	if (debugData.length > 0) {
		ctx.fillStyle = "#000000";
		ctx.font = "10px Arial";
		ctx.fillText(debugData, 10, 200);
	}

	// FPS counter 
	if (showFPS) {
		frames += 1;
		var newTime = performance.now();
		if (newTime - lastFPSCheck > 1000) {
			lastFPSCheck = newTime;
			fps = frames;
			frames = 0;
		}
		ctx.fillStyle = "#000000";
		ctx.font = "20px Arial";
		ctx.fillText(fps, 30, 30);
	}

	// Redraw when available 
	requestAnimationFrame(redraw);

}

// Render a given unitary
function renderUnitary(ctx, states, x, y, qubitsWithGates, goLeft) {

	// Style parameters
	ctx.lineWidth = fontSize / 7;
	ctx.strokeStyle = "#555555";
	ctx.fillStyle = ctx.strokeStyle;
	ctx.font = fontSize/2 + "px Arial";

	// For each matrix element
	var textX = 0;
	var textYReal = 0;
	var textYImag = 0;
	var vertOffset = 1-Math.floor(states[0].length / 2);
	for (var i=0; i<states[0].length; i++) {
		textX = (x+i)*gridX+offsetX+gridX*0.05;
		for (var j=0; j<states[0][i].length; j++) {

			// Draw that element
			textYReal = (y+j+vertOffset)*gridY+offsetY+gridY*0.35;
			textYImag = (y+j+vertOffset)*gridY+offsetY+gridY*0.7;
			if (textX >= -2*fontSize && textX <= canvas.width && textYReal >= -2*fontSize && textYReal <= canvas.height) {
				ctx.fillText((states[0][j][i]<0?"":" ") + states[0][j][i].toFixed(2), textX, textYReal);
				ctx.fillText((states[1][j][i]<0?"":" ") + states[1][j][i].toFixed(2)+"i", textX, textYImag);
			}

		}
	}

}

// Render a given statevector
function renderStatevector(ctx, states, x, y, qubitsWithGates, goLeft) {

	// Style parameters
	ctx.lineWidth = fontSize / 7;
	ctx.strokeStyle = "#555555";
	ctx.fillStyle = ctx.strokeStyle;

	// Get the number of spaces
	var squares = Math.log2(states[0].length);

	// For each state
	var nextPos = 0;
	for (var i=0; i<states[0].length; i++) {

		// If of significant probability
		if (states[0][i]*states[0][i]+states[1][i]*states[1][i] >= cutoffThresh/100.0) {

			// Get the binary representation
			var binRep = i.toString(2).padStart(squares, "0");

			// Extra squares to add for missing qubits
			var ext = 0;

			// For each qubit of the state
			for (var j=0; j<binRep.length; j++) {

				// If there's anything on that qubit
				while (!qubitsWithGates.includes(y+j+ext) && ext <= squares+1) {
					ext += 1;
				}

				// Draw that qubit's state
				textX = (x+nextPos)*gridX+offsetX+gridX*0.27;
				textY = (y+j+ext)*gridY+offsetY+gridY*0.6;
				ctx.font = fontSize + "px Arial";
				ctx.fillText(binRep[j], textX, textY);

			}

			// To simplify the code
			leftX = (x+nextPos)*gridX+offsetX+gateSize/2-gridX*0.4;
			rightX = (x+nextPos)*gridX+offsetX+gateSize/2+gridX*0.4;
			topY = y*gridY+offsetY-(gridY-gateSize)/2;
			bottomY = (y+binRep.length+ext)*gridY+offsetY-(gridY-gateSize)/2;

			// Draw the top part of the ket
			ctx.beginPath();
			ctx.moveTo(leftX, topY);
			ctx.lineTo(rightX, topY);
			ctx.stroke();

			// Probability estimate at the top
			textX = (x+nextPos)*gridX+offsetX+gridX*0.05;
			textYReal = (y-1)*gridY+offsetY+gridY*0.35;
			textYImag = (y-1)*gridY+offsetY+gridY*0.7;
			ctx.font = (fontSize/2)+"px Arial";
			ctx.fillText((states[0][i]<0?"":" ") + states[0][i].toFixed(2), textX, textYReal);
			ctx.fillText((states[1][i]<0?"":" ") + states[1][i].toFixed(2)+"i", textX, textYImag);

			// Draw the bottom part of the ket
			ctx.beginPath();
			ctx.moveTo(leftX, bottomY);
			ctx.lineTo((leftX+rightX)/2, bottomY+gridY*0.2);
			ctx.lineTo(rightX, bottomY);
			ctx.stroke();

			// Next one should be drawn to the right
			nextPos += 1;

		}

	}

}

// Render the given states at the specified position 
function renderState(ctx, states, x, y, qubitsWithGates, goLeft) {

	// Style parameters
	ctx.lineWidth = fontSize / 7;
	ctx.strokeStyle = "#555555";
	ctx.fillStyle = ctx.strokeStyle;

	// For each state
	for (var i=0; i<states.length; i++) {

		// If of significant probability
		if ((i < 10) && (i < 3 || states[i][0] >= cutoffThresh)) {
		
			// For each qubit of the state
			for (var j=0; j<states[i][2].length; j++) {

				// If there's anything on that qubit
				if (qubitsWithGates.indexOf(y+j) >= 0) {

					// Draw that qubit's state
					textX = (x+i)*gridX+offsetX+gridX*0.27;
					textY = (y+j)*gridY+offsetY+gridY*0.6;
					ctx.font = fontSize + "px Arial";
					ctx.fillText(states[i][2][j], textX, textY);

				}

			}

			// To simplify the code
			leftX = (x+i)*gridX+offsetX+gateSize/2-gridX*0.4;
			rightX = (x+i)*gridX+offsetX+gateSize/2+gridX*0.4;
			topY = y*gridY+offsetY-(gridY-gateSize)/2;
			bottomY = (y+states[i][2].length)*gridY+offsetY-(gridY-gateSize)/2;

			// Draw the top part of the ket
			ctx.beginPath();
			ctx.moveTo(leftX, topY);
			ctx.lineTo(rightX, topY);
			ctx.stroke();

			// Probability estimate at the top
			if (states[i][0] >= 100) {
				textX = (x+i)*gridX+offsetX+gridX*0.05;
			} else if (states[i][0] >= 10) {
				textX = (x+i)*gridX+offsetX+gridX*0.15;
			} else {
				textX = (x+i)*gridX+offsetX+gridX*0.2;
			}
			textY = (y-1)*gridY+offsetY+gridY/1.4;
			ctx.font = (fontSize/2)+"px Arial";
			ctx.fillText(states[i][0] + "%", textX, textY);

			// Draw the bottom part of the ket
			ctx.beginPath();
			ctx.moveTo(leftX, bottomY);
			ctx.lineTo((leftX+rightX)/2, bottomY+gridY*0.2);
			ctx.lineTo(rightX, bottomY);
			ctx.stroke();

		}

	}

}

// Calculate the matrix product of two matrices
function matrixProduct(m1, m2) {
    var result = [];
    for (var i=0; i<m1.length; i++) {
        result[i] = [];
        for (var j=0; j<m2[0].length; j++) {
            var sum = 0;
            for (var k=0; k<m1[0].length; k++) {
                sum += m1[i][k] * m2[k][j];
            }
            result[i][j] = sum;
        }
    }
    return result;
}

// Calculate the kronecker/tensor product of two matrices
function tensorProduct(m1, m2) {
	var prod = Array(m1.length*m2.length).fill(null).map(() => Array(m1[0].length*m2[0].length).fill(0));
    for (var i1=0; i1<m1.length; i1++) {
        for (var j1=0; j1<m1[0].length; j1++) {
			for (var i2=0; i2<m2.length; i2++) {
				for (var j2=0; j2<m2[0].length; j2++) {
					prod[i1*m2.length+i2][j1*m2[0].length+j2] = m1[i1][j1] * m2[i2][j2];
				}
			}
		}
	}
	return prod;
}

// Element-wise matrix subtraction
function matrixSubtraction(m1, m2) {
	var mat = Array(m1.length).fill(null).map(() => Array(m1[0].length).fill(0));
    for (var i1=0; i1<m1.length; i1++) {
        for (var j1=0; j1<m1[0].length; j1++) {
			mat[i1][j1] = m1[i1][j1] - m2[i1][j1];
		}
	}	
	return mat;
}

// Element-wise matrix addition
function matrixAddition(m1, m2) {
	var mat = Array(m1.length).fill(null).map(() => Array(m1[0].length).fill(0));
    for (var i1=0; i1<m1.length; i1++) {
        for (var j1=0; j1<m1[0].length; j1++) {
			mat[i1][j1] = m1[i1][j1] + m2[i1][j1];
		}
	}	
	return mat;
}

// Given a gate object, return the corresponding matrix
function gateToMat(gate, gateList, qubitsWithGates) {

	// Separate real and imag components
	var matReal = [[]];
	var matImag = [[]];

	// Pauli X
	if (gate.letter == "X") {
		matReal = [[0, 1],
			       [1, 0]];
		matImag = [[0, 0],
			       [0, 0]];

	// Pauli Y
	} else if (gate.letter == "Y") {
		matReal = [[0, 0],
			       [0, 0]];
		matImag = [[0,-1],
			       [1, 0]];

	// Pauli Z
	} else if (gate.letter == "Z") {
		matReal = [[1, 0],
			       [0,-1]];
		matImag = [[0, 0],
			       [0, 0]];

	// Identity
	} else if (gate.letter == "I") {
		matReal = [[1, 0],
			       [0, 1]];
		matImag = [[0, 0],
			       [0, 0]];

	// S
	} else if (gate.letter == "S") {
		matReal = [[1, 0],
			       [0, 0]];
		matImag = [[0, 0],
			       [0, 1]];

	// T
	} else if (gate.letter == "T") {
		matReal = [[1, 0],
			       [0, 0.707106781]];
		matImag = [[0, 0],
			       [0, 0.707106781]];

	// Hadamard
	} else if (gate.letter == "H") {
		matReal = [[0.707106781, 0.707106781],
			       [0.707106781,-0.707106781]];
		matImag = [[0, 0],
			       [0, 0]];

	// Otherwise change nothing
	} else {
		matReal = [[1]];
		matImag = [[0]];

	}

	// If it's a function, get the pre-calced matrices
	if (gate.letter == "fun") {

		// If there exists a precalced matrix
		if (funcUnitaries[gate.funID]) {
			matReal = funcUnitaries[gate.funID][0];
			matImag = funcUnitaries[gate.funID][1];

		// If there isn't, use an identity
		} else {
			var matReal = Array(Math.pow(2, gate["size"])).fill(null).map(() => Array(Math.pow(2, gate["size"])).fill(0));
			var matImag = Array(Math.pow(2, gate["size"])).fill(null).map(() => Array(Math.pow(2, gate["size"])).fill(0));
			for (var i=0; i<matReal.length; i++) {
				matReal[i][i] = 1;
			}
		}
	}

	// If it's a swap gate
	if (gate.letter == "swaptop") {

		// Create two CNOTs, i.e. cX and Xc
		var fakeGate1 = {"letter": "X", "size": 1, "id": 0, "og": -1, "attached": [1], "y": gate["y"]};
		var fakeControl1 = {"letter": "controlFilled", "size": 1, "id": 1, "og": 0, "y": gateList[fromIDArray(gate.attached[0],gateList)]["y"]};
		var CNOT1 = gateToMat(fakeGate1, [fakeControl1], qubitsWithGates);
		var fakeGate2 = {"letter": "X", "size": 1, "id": 0, "og": -1, "attached": [1], "y": gateList[fromIDArray(gate.attached[0],gateList)]["y"]};
		var fakeControl2 = {"letter": "controlFilled", "size": 1, "id": 1, "og": 0, "y": gate["y"]};
		var CNOT2 = gateToMat(fakeGate2, [fakeControl2], qubitsWithGates);

		// Start with one
		matReal = CNOT1[0];
		matImag = CNOT1[1];

		// Apply the second
		oldReal = matReal.slice();
		matReal = matrixSubtraction(matrixProduct(CNOT2[0], matReal), matrixProduct(CNOT2[1], matImag));
		matImag = matrixAddition(matrixProduct(CNOT2[1], oldReal), matrixProduct(CNOT2[0], oldReal));

		// Apply the first again
		oldReal = matReal.slice();
		matReal = matrixSubtraction(matrixProduct(CNOT1[0], matReal), matrixProduct(CNOT1[1], matImag));
		matImag = matrixAddition(matrixProduct(CNOT1[1], oldReal), matrixProduct(CNOT1[0], oldReal));

	}

	// If it has controls
	if (gate.attached && gate.attached.length > 0 && gate.letter != "swapbottom" && gate.letter != "swaptop") {

		// Get a list of the controls
		var minQubit = gate.y;
		var maxQubit = gate.y + gate.size-1;
		var controlYs = [];
		var invertedControls = [];
		for (var k=0; k<gate.attached.length; k++) {

			// Get the control
			var control = gateList[fromIDArray(gate.attached[k], gateList)];

			// If it exists and isn't a swap, add it
			if (control && control.letter != "swapbottom") {
				controlYs.push(control["y"]);

				// Keep track of which qubits have inverted controls
				if (control["letter"] == "controlUnfilled") {
					invertedControls.push(control["y"]);
				}

				// Also keep track of the min/max
				if (control.y < minQubit) {
					minQubit = control.y;
				}
				if (control.y > maxQubit) {
					maxQubit = control.y;
				}

			}

		}

		// Sort these, so we do the nearest controls first
		controlYs.sort(function(a, b){return Math.abs(a-gate.y) - Math.abs(b-gate.y)});

		// Keep track of how wide the gate is getting as we add controls
		var qubitStart = gate.y;
		var qubitEnd = gate.y + gate.size - 1;

		// Loop over the controls
		for (var k=0; k<controlYs.length; k++) {

			// See how many used qubits difference there is
			var controlDelta = 0;
			if (controlYs[k] < qubitStart) {
				for (var i=controlYs[k]; i<qubitStart; i++) {
					if (qubitsWithGates.includes(i)) {
						controlDelta -= 1;
					}
				}
			} else {
				for (var i=qubitEnd; i<controlYs[k]; i++) {
					if (qubitsWithGates.includes(i)) {
						controlDelta += 1;
					}
				}
			}
			var matFactor = Math.pow(2, Math.abs(controlDelta));

			// Update the sizes
			if (controlDelta < 0) {
				qubitStart += controlDelta;
			} else {
				qubitEnd += controlDelta;
			}

			// The matrix should be bigger
			var fullReal = Array(matFactor*matReal.length).fill(null).map(() => Array(matFactor*matReal[0].length).fill(0));
			var fullImag = Array(matFactor*matImag.length).fill(null).map(() => Array(matFactor*matImag[0].length).fill(0));

			// If negative delta 
			if (controlDelta < 0) {

				// First half are ones
				for (var i=0; i<fullReal.length/2; i++) {
					fullReal[i][i] = 1.0;
				}

				// Then repeat the unitary
				for (var i=0; i<matFactor/2; i++) {
					for (var j1=0; j1<matReal.length; j1++) {
						for (var j2=0; j2<matReal[0].length; j2++) {
							fullReal[fullReal.length/2+j1+i*matReal.length][fullReal[0].length/2+j2+i*matReal[0].length] = matReal[j1][j2];
							fullImag[fullReal.length/2+j1+i*matReal.length][fullReal[0].length/2+j2+i*matReal[0].length] = matImag[j1][j2];
						}
					}
				}

			// If positive delta (but not zero)
			} else if (controlDelta > 0) {

				// Even indices are ones
				for (var i=0; i<fullReal.length; i+=2) {
					fullReal[i][i] = 1.0;
				}

				// For the odd indices, repeat the unitary with spacing
				for (var i=0; i<matFactor/2; i++) {
					for (var j1=0; j1<matReal.length; j1++) {
						for (var j2=0; j2<matReal[0].length; j2++) {
							fullReal[1+j1*matFactor+2*i][1+j2*matFactor+2*i] = matReal[j1][j2];
							fullImag[1+j1*matFactor+2*i][1+j2*matFactor+2*i] = matImag[j1][j2];
						}
					}
				}

			}

			// This is now the new matrix
			matReal = fullReal.slice();
			matImag = fullImag.slice();

		}

		// Create the gate notting the control
		var notGateReal = [[1]];
		var notGateImag = [[0]];

		// Combination of identities and X gates
		var idReal = [[1, 0],[0, 1]];
		var idImag = [[0, 0],[0, 0]];
		var xReal = [[0, 1],[1, 0]];
		var xImag = [[0, 0],[0, 0]];

		// For each qubit
		for (var i=minQubit; i<=maxQubit; i++) {
			if (qubitsWithGates.includes(i)) {

				// If it's the control
				if (invertedControls.includes(i)) {
					oldReal = notGateReal.slice();
					notGateReal = matrixSubtraction(tensorProduct(notGateReal, xReal), tensorProduct(notGateImag, xImag));
					notGateImag = matrixAddition(tensorProduct(notGateImag, xReal), tensorProduct(oldReal, xImag));

				// If it's not
				} else {
					oldReal = notGateReal.slice();
					notGateReal = matrixSubtraction(tensorProduct(notGateReal, idReal), tensorProduct(notGateReal, idImag));
					notGateImag = matrixAddition(tensorProduct(notGateImag, idReal), tensorProduct(oldReal, idImag));

				}

			}
		}

		// Apply it before
		oldReal = matReal.slice();
		matReal = matrixSubtraction(matrixProduct(notGateReal,matReal), matrixProduct(notGateImag,matImag));
		matImag = matrixAddition(matrixProduct(notGateImag,oldReal), matrixProduct(notGateReal,matImag));

		// And after
		oldReal = matReal.slice();
		matReal = matrixSubtraction(matrixProduct(matReal,notGateReal), matrixProduct(matImag,notGateImag));
		matImag = matrixAddition(matrixProduct(oldReal,notGateImag), matrixProduct(matImag,notGateReal));

	}

	return [matReal, matImag];

}

// Given gates and a box, return the unitary
function getUnitary(gates, boundingBox) { 

	// Get valid gates
	var validGates = []
	for (var i=gateOptions; i<gates.length; i++) {
		if (gates[i]["rec"] != true && gates[i]["x"] >= boundingBox[0] && gates[i]["x"] <= boundingBox[1] && gates[i]["y"] >= boundingBox[2] && gates[i]["y"] <= boundingBox[3]) {
			validGates.push(gates[i]);
		}
	}

	// Get the gates per x value
	var gatesPerSection = [];
	var localQubitsWithGates = [];
	var controlStartEnd = [];
	for (var j=0; j<boundingBox[1]-boundingBox[0]-1; j++) {
		var perSection = [];
		for (var i=0; i<validGates.length; i++) {

			// Found a gate with the right x
			if (validGates[i]["x"]-boundingBox[0]-1 == j) {

				// Anything with a control should be by itself
				if (validGates[i].attached && validGates[i].attached.length > 0 && validGates[i].letter != "swapbottom") { 
					var newSection = [];
					var newStartEnd = [validGates[i]["y"]-boundingBox[2], validGates[i]["y"]-boundingBox[2]];
					newSection[validGates[i]["y"]-boundingBox[2]] = validGates[i];
					for (var k=0; k<validGates[i].attached.length; k++) {
						var cont = validGates[fromIDArray(validGates[i].attached[k], validGates)];
						newSection[cont["y"]-boundingBox[2]] = cont;
						if (cont["y"]-boundingBox[2] > newStartEnd[1]) {
							newStartEnd[1] = cont["y"]-boundingBox[2];
						}
						if (cont["y"]-boundingBox[2] < newStartEnd[0]) {
							newStartEnd[0] = cont["y"]-boundingBox[2];
						}
					}
					gatesPerSection.push(newSection);
					controlStartEnd.push(newStartEnd);

				// Otherwise (if it's not attached) add it to this section
				} else if (validGates[i].letter == "fun" || (validGates[i].og == -1 && validGates[i].letter != "swapbottom")) {
					perSection[validGates[i]["y"]-boundingBox[2]] = validGates[i];
				}

				// This qubit has something
				for (var k=0; k<validGates[i]["size"]; k++) {
					if (!localQubitsWithGates.includes(validGates[i]["y"]+k)) {
						localQubitsWithGates.push(validGates[i]["y"]+k);
					}
				}

			}
		}

		// Only add if there are gates present
		if (perSection.length > 0) {
			gatesPerSection.push(perSection);
			controlStartEnd.push([1, -1]);
		}

	}

	// Start with a big identity
	var numQubits = localQubitsWithGates.length;
	var vecSize = Math.pow(2, localQubitsWithGates.length);
	var unitaryReal = Array(vecSize).fill(null).map(() => Array(vecSize).fill(0));
	var unitaryImag = Array(vecSize).fill(null).map(() => Array(vecSize).fill(0));
	for (var i=0; i<vecSize; i++) {
		unitaryReal[i][i] = 1.0;
	}

	// Fill the blanks with identities
	for (var i=0; i<gatesPerSection.length; i++) {
		for (var j=0; j<boundingBox[3]-boundingBox[2]+1; j++) {
			if (!gatesPerSection[i][j]) {

				// If this qubit is used, add an identity
				if (localQubitsWithGates.includes(j+boundingBox[2])
					&& !(j>controlStartEnd[i][0] && j<controlStartEnd[i][1])) {
					gatesPerSection[i][j] = {"letter": "I"};

				// Otherwise add something that won't increase the size
				} else {
					gatesPerSection[i][j] = {"letter": "nullGate"};
				}

			}
		}
	}

	// Make sure everything after functions is null and not identity
	for (var i=0; i<gatesPerSection.length; i++) {
		for (var j=0; j<gatesPerSection[i].length; j++) {
			if (gatesPerSection[i][j].letter == "fun") {
				for (var k=1; k<gatesPerSection[i][j].size; k++) {
					gatesPerSection[i][j+k] = {"letter": "nullGate"};
				}
			}
		}
	}

	// For each section
	for (var i=0; i<gatesPerSection.length; i++) {

		// Skip if it doesn't have any gates
		if (gatesPerSection[i].length == 0) {
			continue;
		}

		// Tensor product all these gates
		var mats = gateToMat(gatesPerSection[i][0], gatesPerSection[i], localQubitsWithGates); 
		toApplyReal = mats[0];
		toApplyImag = mats[1];
		for (var j=1; j<gatesPerSection[i].length; j++) {
			mats = gateToMat(gatesPerSection[i][j], gatesPerSection[i], localQubitsWithGates); 
			oldReal = toApplyReal.slice();
			toApplyReal = matrixSubtraction(tensorProduct(toApplyReal, mats[0]), tensorProduct(toApplyImag, mats[1]));
			toApplyImag = matrixSubtraction(tensorProduct(toApplyImag, mats[0]), tensorProduct(oldReal, mats[1]));
		}

		// Apply it to the state
		oldReal = unitaryReal.slice();
		unitaryReal = matrixSubtraction(matrixProduct(toApplyReal, unitaryReal), matrixProduct(toApplyImag, unitaryImag));
		unitaryImag = matrixAddition(matrixProduct(toApplyReal, unitaryImag), matrixProduct(toApplyImag, oldReal));

	}

	return [unitaryReal, unitaryImag];

}

// Given gates and a box, return the statevector
function getStatevector(gates, boundingBox) {

	// First get the unitary
	units = getUnitary(gates, boundingBox);

	// Extract the first column of both parts
	var statevecReal = [];
	var statevecImag = [];
	for (var i=0; i<units[0].length; i++) {
		statevecReal.push(units[0][i][0]);
		statevecImag.push(units[1][i][0]);
	}

	return [statevecReal, statevecImag];

}

// Given inputs, gates and a box, simulate the circuit and return the states/counts 
function simulateCircuit(inputLocal, gates, boundingBox, repeats, recDepth) {

	// Init the results array
	var resultsLocal = [];

	// List of the gates to apply in order
	var toApply = [];

	// Get valid gates
	var validGates = []
	for (var i=gateOptions; i<gates.length; i++) {
		if (gates[i]["rec"] != true && gates[i]["x"] >= boundingBox[0] && gates[i]["x"] <= boundingBox[1] && gates[i]["y"] >= boundingBox[2] && gates[i]["y"] <= boundingBox[3]) {
			validGates.push(gates[i]);
		}
	}

	// Sort in order
	var sortedGates = validGates.slice();
	sortedGates.sort(function(a, b) {return a["x"] - b["x"];});

	// Repeats a number of times
	for (var i=0; i<repeats; i++) {
	
		// Start with input state with coefficient 1+0i
		var state = inputLocal[2];
		var coeff = inputLocal[1].slice();

		// For each gate in order
		for (var j=0; j<sortedGates.length; j++) {

			// Gate info
			var letter = sortedGates[j]["letter"];
			var target = sortedGates[j]["y"]-boundingBox[2];
			var controlIDs = sortedGates[j]["attached"];

			// Check if controls all valid 
			var controlsValid = true;
			for (var k=0; k<controlIDs.length; k++) {

				// Get control info
				var controlInd = fromIDArray(controlIDs[k], sortedGates);
				var controlQubit = sortedGates[controlInd]["y"]-boundingBox[2];
				var controlFilled = sortedGates[controlInd]["letter"] == "controlFilled";

				// Ensure the attached isn't be used for something else (i.e. swap)
				if (sortedGates[controlInd]["letter"] == "controlFilled" || sortedGates[controlInd]["letter"] == "controlUnfilled") {

					// Check the state of this qubit
					if (controlFilled && state[controlQubit] == "0") {
						controlsValid = false;
					} else if (!controlFilled && state[controlQubit] == "1") {
						controlsValid = false;
					}

				}

			}

			// If controls all valid
			if (controlsValid) {

				// If it's a Hadamard
				if (letter == "H") {

					// 50-50 chance
					var qubitBefore = state[target];
					if (randNums[randInd] < 0.5) {
						state = state.substring(0, target) + (state[target] == "1" ? "0" : "1") + state.substring(target+1, state.length);
					}

					// H|1> = |0>-|1>
					if (qubitBefore == "1" && state[target] == "1") {
					
						// Update coefficient
						coeff[0] = -coeff[0];
						coeff[1] = -coeff[1];

					}

					// Next random number
					randInd += 1;
					if (randInd > numRands) {randInd = 0};

				// If it's an X
				} else if (letter == "X") {

					// Bit flip
					state = state.substring(0, target) + (state[target] == "1" ? "0" : "1") + state.substring(target+1, state.length);

				// If it's a Y
				} else if (letter == "Y") {

					// Update coefficient
					if (state[target] == "1") {
						var temp = coeff[0];
						coeff[0] = -coeff[1];
						coeff[1] = temp;
					} else {
						var temp = coeff[0];
						coeff[0] = coeff[1];
						coeff[1] = -temp;
					}

					// Bit flip
					state = state.substring(0, target) + (state[target] == "1" ? "0" : "1") + state.substring(target+1, state.length);
					
				// If it's a Z
				} else if (letter == "Z" && state[target] == "1") {

					// Update coefficient
					coeff[0] = -coeff[0];
					coeff[1] = -coeff[1];

				// If it's an S
				} else if (letter == "S" && state[target] == "1") {

					// Update coefficient
					var temp = coeff[0];
					coeff[0] = -coeff[1];
					coeff[1] = temp;
				
				// If it's a T 
				} else if (letter == "T" && state[target] == "1") {

					// Update coefficient
					var a = coeff[0];
					var b = coeff[1];
					coeff[0] = (a-b) / Math.sqrt(2);
					coeff[1] = (a+b) / Math.sqrt(2);

				// If it's a swap
				} else if (letter == "swaptop") {

					// Get the location to swap with
					var bottomInd = fromIDArray(sortedGates[j]["attached"][0], sortedGates);
					var bottomTarget = sortedGates[bottomInd]["y"]-boundingBox[2];

					// Cache the things to swap
					var newTop = state.substr(bottomTarget, 1);
					var newBottom = state.substr(target, 1);

					// Make the two replaces
					state = state.substring(0, target) + newTop + state.substring(target+1, state.length);
					state = state.substring(0, bottomTarget) + newBottom + state.substring(bottomTarget+1, state.length);

				// If it's a function 
				} else if (letter == "fun") {
					
					// If gate is valid
					var rectInd = indFromFunID(sortedGates[j]["funID"]);
					if (rectInd >= 0 && recDepth < maxRecDepth) {

						// Prepare the next input state
						var finInd = target + sortedGates[j]["size"]-1;
						var newInput = [100, coeff, state.substring(target, finInd+1)];

						// Sim the function section once
						var newResults = simulateCircuit(newInput, gates, lineStartEnds[rectInd], 1, recDepth+1);

						// Update the main state 
						state = state.substring(0, target) + newResults[0][2] + state.substring(finInd+1, state.length);
						coeff = newResults[0][1];

					}

				}

			}

		}

		// Check if this state has already been added
		var exists = -1;
		for (var k=0; k<resultsLocal.length; k++) {
			if (resultsLocal[k][2] == state) {
				exists = k;
			}
		}

		// If it doesn't exist, add it
		if (exists < 0) {
			resultsLocal.push([1, coeff, state]);

		// Otherwise, increment the count 
		} else {
			resultsLocal[exists][0] += 1;
			resultsLocal[exists][1][0] += coeff[0];
			resultsLocal[exists][1][1] += coeff[1];
		}

	}

	// Only normalise the top-level results
	if (recDepth == 0) {
		
		// Get mag of total vector and normalise each coefficient
		var totalMag = 0;
		for (var i=0; i<resultsLocal.length; i++) {
			resultsLocal[i][0] = Math.sqrt(resultsLocal[i][1][0]**2+resultsLocal[i][1][1]**2);
			resultsLocal[i][1][0] /= resultsLocal[i][0];
			resultsLocal[i][1][1] /= resultsLocal[i][0];
			totalMag += resultsLocal[i][0];
		}

		// Turn counts into probabilities
		for (var i=0; i<resultsLocal.length; i++) {
			resultsLocal[i][0] = Math.round(100 * (resultsLocal[i][0] / totalMag));
		}

	}

	// Sort the states in probability order and return
	resultsLocal.sort(function(a, b) {return b[0] - a[0];});
	return resultsLocal;

}

// Get the index of a rect with a certain function ID
function indFromFunID(funID) {
	for (var m=0; m<lineStartEnds.length; m++) {
		if (lineStartEnds[m][4] == funID) {
			return m;
		}
	}
	return -1;
}

// Return true if two imaginary numbers are similar a+ib = [a, b]
function compareImag(num1, num2) {
	return Math.abs(num1[0]-num2[0]) < 0.1 && Math.abs(num1[1]-num2[1]) < 0.1;
}

// FROM: https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
// Draws a rounded rectangle using the current state of the canvas.
function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
  if (typeof stroke === 'undefined') {
	stroke = true;
  }
  if (typeof radius === 'undefined') {
	radius = 5;
  }
  if (typeof radius === 'number') {
	radius = {tl: radius, tr: radius, br: radius, bl: radius};
  } else {
	var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
	for (var side in defaultRadius) {
	  radius[side] = radius[side] || defaultRadius[side];
	}
  }
  ctx.beginPath();
  ctx.moveTo(x + radius.tl, y);
  ctx.lineTo(x + width - radius.tr, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  ctx.lineTo(x + width, y + height - radius.br);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
  ctx.lineTo(x + radius.bl, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
  ctx.lineTo(x, y + radius.tl);
  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
  ctx.closePath();
  if (fill) {
	ctx.fill();
  }
  if (stroke) {
	ctx.stroke();
  }

}

// Find a gate index from its ID
function fromID(id) {
	for (k=0; k<gates.length; k++) {
		if (gates[k]["id"] == id) {
			return k;
		}
	}
	return -1;
}

// Find a gate index from its ID (from custom array)
function fromIDArray(id, arr) {
	for (k=0; k<arr.length; k++) {
		if (arr[k]["id"] == id) {
			return k;
		}
	}
	return -1;
}

// When mouse is moved above the canvas
function mouseMove(e) {

	// Cache for pasting
	mx = e.clientX;
	my = e.clientY;

	// By default, hide the delete bar
	showDelete = false;

	// Move whatever is selected to the mouse
	if (selected >= 0 && selectionArray.length == 0) {

		// If it's a control, lock it to the x
		if (gates[selected]["letter"] == "controlFilled" || gates[selected]["letter"] == "controlUnfilled") {

			// Move the control
			gates[selected]["x"] = Math.round((e.clientX - offsetX - gateSize / 2) / gridX);
			gates[selected]["y"] = Math.round((e.clientY - offsetY - gateSize / 2) / gridY);

			// Move the og too
			var og = gates[fromID(gates[selected]["og"])];
			og["x"] = gates[selected]["x"];

			// Move any other controls attached to the og 
			for (var j=0; j<og["attached"].length; j++) {
				var otherConInd = fromID(og["attached"][j]);
				if (otherConInd != selected) {
					var other = gates[otherConInd];
					other["x"] = gates[selected]["x"];
				}
			}

		// If it's a function
		} else if (gates[selected]["letter"] == "sub") {

			// Get whichever circuit section it's in 
			var inSection = -1;
			var mouseX = Math.round((e.clientX - offsetX - gateSize / 2) / gridX);
			var mouseY = Math.round((e.clientY - offsetY - gateSize / 2) / gridY);
			for (var j=0; j<lineStartEnds.length; j++) {
				if (mouseX >= lineStartEnds[j][0]-1 && mouseX <= lineStartEnds[j][1]+1 && mouseY >= lineStartEnds[j][2]-1 && mouseY <= lineStartEnds[j][3]+1) {
					inSection = j;
					break;
				}
			}

			// Move it to the top left of that section 
			if (inSection >= 0) {
				gates[selected]["x"] = lineStartEnds[inSection][0]-1;
				gates[selected]["y"] = lineStartEnds[inSection][2]-1;
			} else {
				gates[selected]["x"] = mouseX;
				gates[selected]["y"] = mouseY;
			}

			// Show the delete bar
			showDelete = true;
			
		// If it's a text object
		} else if (gates[selected]["letter"].substring(0,4) == "text") {
			
			// Show the delete bar
			showDelete = true;

			// Move this gate to the mouse, x and y 
			gates[selected]["x"] = Math.round(-dragOffset + (e.clientX - offsetX - gateSize / 2) / gridX);
			newY = Math.round((e.clientY - offsetY - gateSize / 2) / gridY);

			// Update the new y now the delta has been processed
			gates[selected]["y"] = newY;

			// Move any attached (go buttons) too
			if (gates[selected]["attached"].length > 0) {
				goButton = gates[fromID(gates[selected]["attached"][0])]
				goButton["x"] = gates[selected]["x"] + gates[selected]["size"];
				goButton["y"] = gates[selected]["y"];
			}

		// If it's a normal gate
		} else {
			
			// Show the delete bar
			showDelete = true;

			// Move this gate to the mouse, x and y 
			gates[selected]["x"] = Math.round((e.clientX - offsetX - gateSize / 2) / gridX);
			newY = Math.round(-dragOffset + (e.clientY - offsetY - gateSize / 2) / gridY);

			// Move any attached controls along with it
			for (var i=0; i<gates[selected]["attached"].length; i++) {
				control = gates[fromID(gates[selected]["attached"][i])]
				control["x"] = Math.round((e.clientX - offsetX - gateSize / 2) / gridX);
			}

			// Update the new y now the delta has been processed
			gates[selected]["y"] = newY;

		}
		
		// Update the qubit line preview
		recalcRecs = true;

	// If dragging multiple gates 
	} else if (selected >= 0 && selectionArray.length > 0) {

		// Determine the deltas from the selected gate
		if (gates[selected]["letter"].substring(0,4) == "text") {
			deltaX = Math.round(-dragOffset + (e.clientX - offsetX - gateSize / 2) / gridX) - gates[selected]["x"];
		} else {
			deltaX = Math.round((e.clientX - offsetX - gateSize / 2) / gridX) - gates[selected]["x"];
		}
		deltaY = Math.round((e.clientY - offsetY - gateSize / 2) / gridY) - gates[selected]["y"];

		// Show the delete bar
		showDelete = true;

		// For each gate to move 
		for (var k=0; k<selectionArray.length; k++) {

			// For readability
			var sel = selectionArray[k];

			// If it's not a control
			if (gates[sel]["letter"] != "controlFilled" && gates[sel]["letter"] != "controlUnfilled" && gates[sel]["letter"] != "swapbottom") {
				
				// Move this gate to the mouse, x and y
				gates[sel]["x"] += deltaX;
				gates[sel]["y"] += deltaY;

				// Move any attached controls along with it
				for (var i=0; i<gates[sel]["attached"].length; i++) {
					control = gates[fromID(gates[sel]["attached"][i])]
					control["x"] += deltaX;
				}

			// If it's the bottom of a swap gate
			} else if (gates[sel]["letter"] == "swapbottom") {

				// If the top part isn't in the selection
				var other = fromID(gates[sel]["attached"][0]);
				if (selectionArray.indexOf(other) < 0) {

					// Move this gate to the mouse x
					gates[sel]["x"] += deltaX;

					// Move the og too
					gates[other]["x"] += deltaX;

				}

				// Follow the y always
				gates[sel]["y"] += deltaY;
				
			// If a control 
			} else {

				// Who's og isn't in the selection
				var og = fromID(gates[sel]["og"]);
				if (selectionArray.indexOf(og) < 0) {
				
					// Move this gate to the mouse x
					gates[sel]["x"] += deltaX;

					// Move the og too
					gates[og]["x"] = gates[sel]["x"];

					// Also move any other controls attached to that og 
					for (var j=0; j<gates[og]["attached"].length; j++) {
						var otherConInd = fromID(gates[og]["attached"][j]);
						if (otherConInd != sel && selectionArray.indexOf(otherConInd) < 0) {
							var other = gates[otherConInd];
							other["x"] += deltaX;
						}
					}

				}

				// Follow the y always
				gates[sel]["y"] += deltaY;

			}

		}

		// Update the qubit line preview
		recalcRecs = true;

	// If dragging the background
	} else if (selected == -5) {

		// Move the offsets
		offsetX += e.movementX;
		offsetY += e.movementY;

	// If selecting
	} else if (selected == -6) {

		// Change the pointer
		canvas.style.cursor = "pointer";

		// Set the end X/Y 
		selectEndX = e.clientX;
		selectEndY = e.clientY;

		// Invert if needed
		if (selectStartX < selectEndX) {
			selMinX = selectStartX;
			selMaxX = selectEndX;
		} else {
			selMinX = selectEndX;
			selMaxX = selectStartX;
		}
		if (selectStartY < selectEndY) {
			selMinY = selectStartY;
			selMaxY = selectEndY;
		} else {
			selMinY = selectEndY;
			selMaxY = selectStartY;
		}

		// Check over every gate
		selectionArray = [];
		for (var i=gateOptions; i<gates.length; i++) {

			// Add the offset
			gx = gates[i]["x"]*gridX+offsetX;
			gy = gates[i]["y"]*gridY+offsetY;

			// Check for mouse within gate area
			if (selMinX < gx && selMaxX > gx+gateSize && selMinY < gy && selMaxY > gy+gateSize) {
				selectionArray.push(i);
			}

		}

	// Otherwise check for hover
	} else if (canEdit) {

		// Reset things
		canvas.style.cursor = "initial";
		hover = -1;

		// Check over every draggable gate 
		for (var i=0; i<gates.length; i++) {
			if (gates[i]["draggable"]) {

				// Get the dimensions to check
				var gxMin = gates[i]["x"]*gridX+offsetX;
				var gyMin = gates[i]["y"]*gridY+offsetY;
				var gxMax = gxMin + gateSize;
				var gyMax = gyMin + gateSize;
				var perSizeY = gridY;
				var perSizeX = gridX;

				// If it's not a text object 
				if (gates[i]["letter"].substring(0,4) != "text") {

					// Check for mouse within gate area 
					for (var j=0; j<gates[i]["size"]; j++) {
						if (e.clientX > gxMin && e.clientX < gxMax && e.clientY > gyMin && e.clientY < gyMax+j*perSizeY) {
							canvas.style.cursor = "pointer";
							hover = i;
							dragOffset = j;
							break;
						}
					}
					
				// If it's a text object 
				} else {

					// Check for mouse within gate area 
					for (var j=0; j<gates[i]["size"]; j++) {
						if (e.clientX > gxMin && e.clientX < gxMax+j*perSizeX && e.clientY > gyMin && e.clientY < gyMax) {
							canvas.style.cursor = "pointer";
							hover = i;
							dragOffset = j;
							break;
						}
					}

				}

			}

		}

		// Check over every non-draggable (i.e. toolbar) gate 
		for (var i=0; i<gates.length; i++) {
			if (!gates[i]["draggable"] && (i==0||i>toolbarGates.length||(i>toolbarIndex&&i<toolbarIndex+numGatesToShow+1))) {

				// Get the dimensions to check
				var gxMin = gates[i]["x"]*gridXFixed;
				var gyMin = gates[i]["y"]*gridYFixed;
				var gxMax = gxMin + gateSizeFixed;
				var gyMax = gyMin + gateSizeFixed;
				var perSizeY = gridYFixed;
				var perSizeX = gridXFixed;

				// Check for mouse within gate area 
				for (var j=0; j<gates[i]["size"]; j++) {
					if (e.clientX > gxMin && e.clientX < gxMax && e.clientY > gyMin && e.clientY < gyMax+j*perSizeY) {
						canvas.style.cursor = "pointer";
						hover = i;
						dragOffset = j;
						break;
					}
				}

			}

		}

		// Check for other button hover  
		openHover = false;
		saveHover = false;
		if (loadOpen && e.clientX > openDims[0] && e.clientX < openDims[1] && e.clientY > openDims[2] && e.clientY < openDims[3]) {
			openHover = true;
			canvas.style.cursor = "pointer";
		} else if (saveOpen && e.clientX > saveDims[0] && e.clientX < saveDims[1] && e.clientY > saveDims[2] && e.clientY < saveDims[3]) {
			saveHover = true;
			canvas.style.cursor = "pointer";
		} else if (hover == -1 && selected == -1) {
			canvas.style.cursor = "initial";
		}

	}

}

// When mouse button lifted up
function mouseUp(e) {

	// Hide the delete bar
	showDelete = false;

	// If something is selected 
	if (selected >= 0 && selectionArray.length == 0) {

		// If it's a control
		if (gates[selected]["letter"] == "controlFilled" || gates[selected]["letter"] == "controlUnfilled") {

			// Get the parent
			var og = fromID(gates[selected]["og"]);
			var shouldDelete = false;

			// If dropped onto another control of the parent
			var controlList = gates[og]["attached"].slice();
			for (var i=0; i<controlList.length; i++) {
				if (controlList[i] != gates[selected]["id"] && gates[selected]["y"] == gates[fromID(controlList[i])]["y"]) {
					shouldDelete = true;
				}
			}

			// If dropped onto the parent
			if (gates[selected]["x"] == gates[og]["x"] && gates[selected]["y"] >= gates[og]["y"] && gates[selected]["y"] <= gates[og]["y"]+gates[og]["size"]-1) {
				shouldDelete = true;
			}

			// If either of these conditions is true
			if (shouldDelete) {

				// Remove from the attached list of its parent
				gates[og]["attached"].splice(gates[og]["attached"].indexOf(gates[selected]["id"]), 1);

				// Remove this gate
				gates.splice(selected, 1);

			}

		// If not a control
		} else {

			// If dropped into the toolbar 
			if (e.clientX > toolbarOffsetX && e.clientX < toolbarOffsetX+toolbarWidth && e.clientY > 0 && e.clientY < toolbarHeight) {

				// Cache the list of controls to remove
				var controlList = gates[selected]["attached"].slice();

				// Remove this gate (done first since selected is a fixed index)
				gates.splice(selected, 1);

				// Remove all its controls
				for (var i=0; i<controlList.length; i++) {
					gates.splice(fromID(controlList[i]), 1);
				}
				
			// If a swap is dropped onto the other half
			} else if (gates[selected]["letter"] == "swaptop" || gates[selected]["letter"] == "swapbottom") {

				// Check that the ys are the same
				if (gates[selected]["y"] == gates[fromID(gates[selected]["attached"][0])]["y"]) {

					// Remove this
					var otherID = gates[selected]["attached"][0];
					gates.splice(selected, 1);

					// Remove the other
					gates.splice(fromID(otherID), 1);

				}

			// If dropped onto a control
			} else if (gates[selected]["attached"] && gates[selected]["attached"].length > 0) {

				// Cache the list of controls to remove
				var controlList = gates[selected]["attached"].slice();

				// Check all of the controls
				for (var i=0; i<controlList.length; i++) {
					if (gates[selected]["y"] == gates[fromID(controlList[i])]["y"]) {

						// Remove from the gate list
						gates.splice(fromID(controlList[i]), 1);

						// Remove from the parent
						gates[selected]["attached"].splice(i, 1);

					}
					
				}

			}

		}

		// Circuit has changed
		circuitUpdates = 1;

	// If many selected 
	} else if (selected > 0 && selectionArray.length > 0) {

		// If dropped into the toolbar 
		if (e.clientX > toolbarOffsetX && e.clientX < toolbarOffsetX+toolbarWidth && e.clientY > 0 && e.clientY < toolbarHeight) {

			// Get the list of IDs to remove
			idsToRemove = [];
			for (var k=0; k<selectionArray.length; k++) {
				idsToRemove.push(gates[selectionArray[k]]["id"]);
				for (var i=0; i<gates[selectionArray[k]]["attached"].length; i++) {
					idsToRemove.push(gates[selectionArray[k]]["attached"][i]);
				}
			}

			// Remove all of these
			for (var k=0; k<idsToRemove.length; k++) {
				var ind = fromID(idsToRemove[k]);
				if (ind >= gateOptions) {
					gates.splice(ind, 1);
				}
			}

			// Stop selecting everything since they no longer exist
			selectionArray = [];

		}

		// Circuit has changed
		circuitUpdates = 1;

	}

	// When dragging in the swap, let the first click move the top/bottom
	if (justCreateMulti) {
		justCreateMulti = false;
		selectionArray = [];
	}
	
	// Deselect current gate 
	selected = -1;
	mouseMove(e);

}

// When key pressed down 
function keyDown(e) {

	// If something that requires selection
	var copyArray = [];
	var ids = [];
	if (e.key == "Delete" || (e.ctrlKey && (e.key == "c" || e.key == "x"))) {

		// Also select hover
		if (selectionArray.length == 0) {
			if (hover >= 0 && selectionArray.indexOf(hover) < 0) {
				selectionArray.push(hover);
			}
			if (selected >= 0 && selectionArray.indexOf(selected) < 0) {
				selectionArray.push(selected);
			}
		}

		// Add everything in the selection array
		if (selectionArray.length > 0) {
			for (var i=0; i<selectionArray.length; i++) {

				// Don't add lone controls 
				if (gates[selectionArray[i]]["letter"].substr(0,7) != "control") {

					// Add that gate
					var newID = gates[selectionArray[i]]["id"];
					if (ids.indexOf(newID) < 0) {
						copyArray.push(gates[selectionArray[i]]);
						ids.push(newID);
					}

					// Also add controls
					var ind = selectionArray[i];
					for (var j=0; j<gates[ind]["attached"].length; j++) {
						var newID = gates[ind]["attached"][j];
						if (ids.indexOf(newID) < 0) {
							copyArray.push(gates[fromID(newID)]);
							ids.push(newID);
						}
					}

				// If ctrl-xing a control, delete but don't copy
				} else {
					var newID = gates[selectionArray[i]]["id"];
					if (ids.indexOf(newID) < 0) {
						ids.push(newID);
					}
				}

			}

		}

	// Undo ctrl-z 
	} else if (e.ctrlKey && e.key == "z") {

		// If not at the earliest
		if (historyIndex > 0) {

			// Move the index back one
			historyIndex -= 1;
			
			// Get it and process it
			asQasm = decodeURIComponent(qasmHistory[historyIndex]);

			// Load the gates from this
			fromQASM(asQasm, true);
		
			// Things have changed, update 
			selectionArray = [];
			noHistory = true;
			circuitUpdates = 2;

		}

	// Redo ctrl-shift-z 
	} else if (e.ctrlKey && e.shiftKey && e.key == "Z") {

		// If not at the end of the history
		if (historyIndex < qasmHistory.length-1) {

			// Move the index forward one
			historyIndex += 1;

			// Get it and process it
			asQasm = decodeURIComponent(qasmHistory[historyIndex]);

			// Load the gates from this
			fromQASM(asQasm, true);

			// Things have changed, update 
			selectionArray = [];
			noHistory = true;
			circuitUpdates = 2;

		}

	}

	// Copying with ctrl-c or ctrl-x
	if (copyArray.length > 0 && e.ctrlKey && (e.key == "c" || e.key == "x")) {

		// Copy to invis object and then copy that
		copyElement.value = JSON.stringify(copyArray);
		copyElement.select();
		document.execCommand("copy");

	// Pasting with ctrl-v
	} else if (e.ctrlKey && e.key == "v") {

		// Force the user to paste into an invis box
		copyElement.select();
		copyElement.focus();

	}

	// If deleting or cutting
	if (e.key == "x" || e.key == "Delete") {

		// Delete everything selected 
		for (var i=0; i<ids.length; i++) {

			// Ensure it's valid
			ind = fromID(ids[i]);
			if (ind >= 0) {

				// Remove this id from the og attached list 
				if (gates[ind]["og"] >= 0) {
					var ogInd = fromID(gates[ind]["og"]);
					if (ogInd >= 0) {
						gates[ogInd]["attached"].splice(gates[ogInd]["attached"].indexOf(ids[i]),1);
					}
				}

				// Remove the gate itself
				gates.splice(ind, 1);

			}
		}

		// Things have changed, update 
		selectionArray = [];
		circuitUpdates = 1;

	}

}

// Trigged on paste
function onTextPaste(t) {

	// Turn back into JS objects
	var asArray = JSON.parse(t.data);

	// Hide the help if pasting onto a new page
	helpOpen = false;

	// Ensure something valid is pasted
	if (asArray != null) {

		// Determine the top left coord
		var minX = 99999999;
		var minY = 99999999;
		for (var i=0; i<asArray.length; i++) {
			if (asArray[i]["x"] < minX) {
				minX = asArray[i]["x"];
			} 
			if (asArray[i]["y"] < minY) {
				minY = asArray[i]["y"];
			} 
		}

		// Add all these to the main array, with updated indices
		selectionArray = [];
		beforeToAfter = {"-1": -1};
		for (var i=0; i<asArray.length; i++) {
			var newGate = asArray[i];
			beforeToAfter[newGate["id"].toString()] = nextID;
			newGate["id"] = nextID;
			newGate["x"] += Math.floor(((mx-offsetX) / gridX) - minX);
			newGate["y"] += Math.floor(((my-offsetY) / gridY) - minY);
			nextID += 1;
			gates.push(newGate);
		}

		// Ensure og/attached are consistent
		for (var i=gates.length-asArray.length; i<gates.length; i++) {
			for (var j=0; j<gates[i]["attached"].length; j++) {
				gates[i]["attached"][j] = beforeToAfter[gates[i]["attached"][j].toString()];
			}
			gates[i]["og"] = beforeToAfter[gates[i]["og"].toString()];
		}

		// Things have changed, update 
		circuitUpdates = 1;

	}
	
}

// When mouse button pressed down
function mouseDown(e) {

	// Get the current time in milliseconds
	var currentTime = new Date().getTime();

	// If it's the second open icon 
	if (openHover) {

		// See what's in the selection box
		var ind = inputBox.selectedIndex;

		// If asking to load a local file
		if (ind == 0) {

			// Open the file input box
			document.getElementById("fileIn").click(); 

		// If loading some sort of preset 
		} else {

			// Hide the load window
			loadOpen = false;
			openHover = false;
			
			// Get it and process it
			asQasm = decodeURIComponent(presets[ind][1]);

			// Reset the history 
			qasmHistory = [];
			historyIndex = -1;

			// Load the gates from this
			fromQASM(asQasm);

			// Re-sim 
			circuitUpdates = 2;

		}

	// If it's the second save icon  
	} else if (saveHover) {

		// See what's in the selection box
		var ind = outputBox.selectedIndex;
		var type = saveTypes[ind];

		// Things that vary based on the chosen type
		var fileText = "";
		var extension = "";

		// If QASM 3.0
		if (type == "QASM 3.0") {
			fileText = toQASM(3);
			extension = ".qasm";

		// If QASM 2.0 (slight differences, but mostly the same)
		} else if (type == "QASM 2.0") {
			fileText = toQASM(2);
			extension = ".qasm";

		// If SVG 
		} else if (type == "SVG") {
			svgWrap()
			fileText = svgString;
			extension = ".svg";

		// If to unitary CSV
		} else if (type == "Unitary CSV") {

			// Find the highest lineStartEnds
			var bestInd = 0;
			var bestY = 10000000000;
			for (var j=0; j<lineStartEnds.length; j++) {
				if (lineStartEnds[j][2] < bestY) {
					bestInd = j;
					bestY = lineStartEnds[j][2];
				}
			}

			// Get the unitary
			inputs[i] = [[100, [1, 0], ""]]
			for (var j=0; j<1+lineStartEnds[bestInd][3]-lineStartEnds[bestInd][2]; j++) {
				inputs[i][0][2] += "0";
			}
			unit = getUnitary(gates, lineStartEnds[bestInd]);

			// Convert this to CSV
			fileText = unitToCSV(unit);
			extension = ".csv";

		}

		// Prompt the user to download the file
		download("circuit"+extension, fileText);

		// Hide the save window
		saveOpen = false;
		saveHover = false;
		
	// If hovering over a gate
	} else if (hover >= 0) {

		// If showing the help, close it 
		if (helpOpen) {
			helpOpen = false;
		}

		// If it's the left button
		if (gates[hover]["letter"] == "left") {

			// Shift the shown gates left
			toolbarIndex -= numGatesToShow;

			// Wrap around
			if (toolbarIndex < 0) {
				toolbarIndex = Math.floor(toolbarGates.length/(numGatesToShow+1))*numGatesToShow;
			}

		// If it's the right button
		} else if (gates[hover]["letter"] == "right") {

			// Shift the shown gates left
			toolbarIndex += numGatesToShow;

			// Wrap around
			if (toolbarIndex >= toolbarGates.length) {
				toolbarIndex = 0;
			}

		// Double click 
		} else if ((currentTime - lastClickTime) < doubleClickMilli) {

			// If it can be dragged (i.e. not in the toolbar)
			if (gates[hover]["draggable"] && gates[hover]["letter"] != "go") {

				// If it's a filled control
				if (gates[hover]["letter"] == "controlFilled") {

					// Change it to be unfilled
					gates[hover]["letter"] = "controlUnfilled";
					circuitUpdates = 1;

				// If it's a filled control
				} else if (gates[hover]["letter"] == "controlUnfilled") {

					// Change it to be unfilled
					gates[hover]["letter"] = "controlFilled";
					circuitUpdates = 1;

				// If it's a sub gate
				} else if (gates[hover]["letter"] == "sub") {

					// Create a sub call at the cursor
					gates.push({"id": nextID, "funID": gates[hover]["funID"],"letter": "fun", "x": Math.round(gates[hover]["x"]), "y": Math.round(gates[hover]["y"]), "size": 1, "draggable": true, "og": gates[hover]["id"], "attached":[]})
					nextID += 1;

					// Select this new gate
					selected = gates.length-1;
					hover = gates.length-1;

				// If it's a text object 
				} else if (gates[hover]["letter"].substring(0,4) == "text") {

					// Open a prompt to change the text 
					inPrompt = true;
					var newText = prompt("Enter new text:", gates[hover]["letter"].substr(4));

					// If the user didn't cancel
					if (newText !== null) {

						// Update the gate's text and size
						gates[hover]["letter"] = "text" + newText;
						ctx.font = fontSize + "px Arial";
						gates[hover]["size"] = Math.max(1, Math.ceil(ctx.measureText(newText).width / gridX))
						circuitUpdates = 1;

						// If it's a link 
						if (newText.substr(0,4) == "http") {

							// Create a go button
							gates.push({"id": nextID, "letter": "go", "x": Math.round(gates[hover]["x"]+gates[hover]["size"]), "y": Math.round(gates[hover]["y"]), "size": 1, "draggable": true, "og": gates[hover]["id"], "attached":[]})
							gates[hover]["attached"].push(nextID);
							nextID += 1;

						// If link no longer valid
						} else if (gates[hover]["attached"].length > 0) {

							// Remove the go button
							var ind = fromID(gates[hover]["attached"]);
							gates.splice(ind, 1);
							gates[hover]["attached"] = [];

						}

					}

				// If it's a normal gate (and not selecting many)
				} else if (selectionArray.length == 0 && gates[hover]["letter"].substr(0,4) != "swap") {

					// Create a control at the cursor
					gates.push({"id": nextID, "letter": "controlFilled", "x": Math.round(gates[hover]["x"]), "y": Math.round(gates[hover]["y"]), "size": 1, "draggable": true, "og": gates[hover]["id"], "attached":[]})
					nextID += 1;

					// Add this control to the attached list of the og gate
					gates[hover]["attached"].push(nextID-1);

					// Select this new control
					selected = gates.length-1;
					hover = gates.length-1;

				}
				
			}

		// Single click
		} else {

			// If selecting something not already selected
			if (selectionArray.indexOf(hover) == -1) {
				selectionArray = [];
			}
			
			// If it's a link's go button
			if (gates[hover]["letter"] == "go") {

				// Get and open the URL 
				var ogInd = fromID(gates[hover]["og"]);
				var url = gates[ogInd]["letter"].substr(4);
				linkObject.href = url;
				linkObject.click();

			// If it can be dragged, select it
			} else if (gates[hover]["draggable"]) {
				selected = hover;

			// If it's the text icon, create a text object 
			} else if (gates[hover]["letter"] == "text") {
				gates.push({"id": nextID, "letter": "textdouble click to edit", "x": Math.round(gates[hover]["x"]), "y": Math.round(gates[hover]["y"]), "size": 7, "og": -1, "draggable": true, "attached":[]})
				dragOffset = 2;
				nextID += 1;
				selected = gates.length-1;
				hover = gates.length-1;

			// If it's the save icon 
			} else if (gates[hover]["letter"] == "save") {

				// Open the saving choice box
				saveOpen = !saveOpen;
				loadOpen = false;
				settingsOpen = false;

			// If it's the open icon 
			} else if (gates[hover]["letter"] == "open") {

				// Open the loading choice box
				loadOpen = !loadOpen;
				saveOpen = false;
				settingsOpen = false;

			// If it's the settings icon 
			} else if (gates[hover]["letter"] == "settings") {

				// Open the settings box
				settingsOpen = !settingsOpen;
				saveOpen = false;
				loadOpen = false;

			// If it's a new function
			} else if (gates[hover]["letter"] == "sub") {
				gates.push({"id": nextID, "funID": nextFunctionID, "letter": gates[hover]["letter"], "x": Math.round(gates[hover]["x"]), "y": Math.round(gates[hover]["y"]), "og": -1, "size": 1, "draggable": true, "attached":[]})
				nextID += 1;
				nextFunctionID += 1;
				selected = gates.length-1;
				hover = gates.length-1;

			// If it's a swap gate (which has two parts) 
			} else if (gates[hover]["letter"] == "swap") {
				gates.push({"id": nextID, "letter": "swaptop", "x": Math.round(gates[hover]["x"]), "y": Math.round(gates[hover]["y"]), "size": 1, "draggable": true, "og": -1, "attached":[nextID+1]})
				hover = gates.length-1;
				selected = gates.length-1;
				selectionArray.push(gates.length-1);
				nextID += 1;
				gates.push({"id": nextID, "letter": "swapbottom", "x": Math.round(gates[hover]["x"]), "y": Math.round(gates[hover]["y"])+1, "size": 1, "draggable": true, "og": -1, "attached":[nextID-1]})
				selectionArray.push(gates.length-1);
				justCreateMulti = true;
				nextID += 1;
				mouseMove(e);

			// If it can't be dragged, create a new gate and select that 
			} else {
				gates.push({"id": nextID, "letter": gates[hover]["letter"], "x": Math.round(gates[hover]["x"]), "y": Math.round(gates[hover]["y"]), "size": 1, "draggable": true, "og": -1, "attached":[]})
				nextID += 1;
				selected = gates.length-1;
				hover = gates.length-1;
				loadOpen = false;
				saveOpen = false;
				settingsOpen = false;
				mouseMove(e);
			}


		}

	// If not hovering over anything
	} else {

		// Stop selecting things
		selectionArray = [];
		loadOpen = false;
		saveOpen = false;
		settingsOpen = false;
		
		// Double click
		if ((currentTime - lastClickTime) < doubleClickMilli) {

			// The user is now selecting
			selected = -6;
			selectStartX = e.clientX;
			selectStartY = e.clientY;
			selectEndX = e.clientX;
			selectEndY = e.clientY;

		// Single click
		} else if (!helpOpen) {

			// The user is now dragging the canvas
			selected = -5

		}
		
	}

	// Save this time for future double click checks
	lastClickTime = currentTime;

}

// Convert a unitary to CSV file text
function unitToCSV(unit) {

	// Split into the real and imag components
	unitReal = unit[0];
	unitImag = unit[1];

	// For each row
	var csvText = "";
	var rowText = "";
	for (var i=0; i<unitReal.length; i++) {
		rowText = "";

		// The element of the row, bar the last
		for (var j=0; j<unitReal[i].length-1; j++) {
			rowText += unitReal[i][j] + "," + unitImag[i][j] + ",";
		}

		// The last (without comma at the end)
		rowText += unitReal[i][unitReal[i].length-1] + "," + unitImag[i][unitReal[i].length-1];

		// This row is done
		csvText += rowText + "\n";

	}

	return csvText;

}

// Convert the circuit and all info into a qasm string 
function toQASM(version=3) {

	// Required at the start of the QASM file
	var qasmString = "";

	// Add text objects with position info 
	for (var i=gateOptions; i<gates.length; i++) {
		if (gates[i]["letter"].substring(0,4) == "text") {
			qasmString += "// " + gates[i]["x"] + " " + gates[i]["y"] + " " + gates[i]["letter"].substr(4) + "\n";
		}
	}

	// For each section
	for (var k=0; k<lineStartEnds.length; k++) {

		var qasmSubstring = "";

		// Is this section a function definition?
		var isFunc = (lineStartEnds[k][4] != -1);

		// Determine how many qubits are needed for the main circuit
		var minQubit = 9999;
		var maxQubit = -9999;
		var minPos = 9999;
		var maxPos = -9999;
		var validGates = []
		for (var i=gateOptions; i<gates.length; i++) {

			// Ignore subroutine definition gates and invalid gates
			if (gates[i]["letter"] != "sub" && gates[i]["rec"] != true) {

				// See if this gate is part of the circuit
				if (gates[i]["x"] >= lineStartEnds[k][0] && gates[i]["x"] <= lineStartEnds[k][1] && gates[i]["y"] >= lineStartEnds[k][2] && gates[i]["y"] <= lineStartEnds[k][3]) {
					validGates.push(gates[i]);

					// Determine min/maxes
					if (gates[i]["y"] < minQubit) {
						minQubit = gates[i]["y"];
					}
					if (gates[i]["y"]+gates[i]["size"]-1 > maxQubit) {
						maxQubit = gates[i]["y"]+gates[i]["size"]-1;
					}
					if (gates[i]["x"] > maxPos) {
						maxPos = gates[i]["x"];
					}
					if (gates[i]["x"] < minPos) {
						minPos = gates[i]["x"];
					}

				}

			}

		}

		// Add the bit specifying a gate
		if (isFunc) {
			qasmSubstring += "gate f" + lineStartEnds[k][4] + " ";
			qasmSubstring += "q0";
			for (var i=1; i<1+maxQubit-minQubit; i++) {
				qasmSubstring += "," + "q" + i;
			}
			qasmSubstring += " // " + (lineStartEnds[k][0]-1) + " " + (lineStartEnds[k][2]-1);
			qasmSubstring += "\n{\n";

		// Or just a register if not a function 
		} else {
			if (version == 2) {
				qasmSubstring += "qreg q[" + (1+maxQubit-minQubit) + "];";
			} else {
				qasmSubstring += "qubit q[" + (1+maxQubit-minQubit) + "];";
			}
			qasmSubstring += " // " + minPos + " " + minQubit;
			qasmSubstring += "\n";
		}

		// Keep track of what the latest position for each qubit is
		var latestX = [];
		for (var i=0; i<1+maxQubit-minQubit; i++) {
			latestX.push(0);
		}

		// Create a copy of the array
		var copy = validGates.slice();

		// Sort the list, leftmost gates first
		copy.sort(function(a, b) {return a["x"] - b["x"];});

		// Loop over this sorted list
		for (var i=0; i<copy.length; i++) {

			// Get info about this gate
			var xPos = copy[i]["x"]-minPos+1;
			var qubit = copy[i]["y"]-minQubit;
			var letter = copy[i]["letter"].toLowerCase();
			var controls = copy[i]["attached"];
			var numControls = controls.length;
			var forced = false;

			// If it's a top part, also consider controls on the bottom
			if (letter == "swaptop") {
				var botInd = fromIDArray(copy[i]["attached"][0], copy);
				var bottomControls = copy[botInd]["attached"];
				for (var j=1; j<bottomControls.length; j++) {
					controls.push(bottomControls[j]);
				}
			}

			// Function calls need their id too
			if (letter == "fun") {
				letter = "f" + copy[i]["funID"];
			}

			// Match the notation
			if (letter == "i") {
				letter = "id";
				forced = true;
			}

			// Don't add controls directly
			if (letter != "swapbottom" && letter != "controlfilled" && letter != "controlunfilled") {

				// Without controls
				if (numControls == 0) {

					// Determine whether there's any free space behind it 
					var numIdenNeeded = xPos-latestX[qubit]-1;
					for (var j=qubit; j<qubit+copy[i]["size"]; j++) {
						if (xPos-latestX[j]-1 < numIdenNeeded) {
							numIdenNeeded = xPos-latestX[j]-1;
						}
					}

					// Add identities if there's free space 
					for (var j=0; j<numIdenNeeded; j++) {
						qasmSubstring += "id q[" + qubit + "];\n";
					}

					// Add the targets
					qasmSubstring += letter + " ";
					for (var j=qubit; j<qubit+copy[i]["size"]; j++) {
						if (j != qubit) {
							qasmSubstring += ",";
						}
						if (isFunc) {
							qasmSubstring += "q" + j;
						} else {
							qasmSubstring += "q[" + j + "]";
						}
					}

					// The main operation is done
					qasmSubstring += ";";

					// If it should be force added
					if (forced) {
						qasmSubstring += " // forced";
					}

					// Add the newline
					qasmSubstring += "\n";

					// Update the offset between the min and max
					minGateQubit = qubit;
					maxGateQubit = qubit+copy[i]["size"]-1;
					for (var j=minGateQubit; j<maxGateQubit+1; j++) {
						latestX[j] = xPos;
					}

				// With controls
				} else {

					// Pre-calculate control indices (since this could get costly for bigger circuits)
					controlIndices = [];
					for (var j=0; j<numControls; j++) {
						controlIndex = fromIDArray(controls[j], copy);
						controlIndices.push(controlIndex);
					}

					// Get the min/max qubit for this gate
					minGateQubit = qubit;
					maxGateQubit = qubit+copy[i]["size"]-1;
					for (var j=0; j<numControls; j++) {
						controlQubit = copy[controlIndices[j]]["y"]-minQubit;
						if (controlQubit > maxGateQubit) {
							maxGateQubit = controlQubit;
						}
						if (controlQubit < minGateQubit) {
							minGateQubit = controlQubit;
						}
					}

					// Determine whether there's any free space behind it
					numIdenNeeded = xPos-latestX[qubit]-1;
					closestIndex = qubit;
					for (var j=minGateQubit; j<maxGateQubit+1; j++) {
						if (xPos-latestX[j]-1 < numIdenNeeded) {
							numIdenNeeded = xPos-latestX[j]-1;
							closestIndex = j;
						}
					}

					// Add identities if there's free space 
					for (var j=0; j<numIdenNeeded; j++) {
						if (isFunc) {
							qasmSubstring += "id q" + closestIndex + ";\n";
						} else {
							qasmSubstring += "id q[" + closestIndex + "];\n";
						}
					}

					// Add the ccc...ch
					for (var j=numControls-1; j>=0; j--) {
						controlIndex = controlIndices[j];
						type = copy[controlIndex]["letter"];
						if (type == "controlFilled") {
							qasmSubstring += "ctrl @ ";
						} else if (type == "controlUnfilled") {
							qasmSubstring += "negctrl @ ";
						}
					}

					// Doesn't matter that it's just one of two
					if (letter == "swaptop") {
						letter = "swap";
					}

					// Add the main gate and see if this has already been used
					qasmSubstring += letter + " ";

					// Add the controls q[1], q[2] etc.
					for (var j=numControls-1; j>=0; j--) {
						controlIndex = controlIndices[j];
						controlQubit = copy[controlIndex]["y"]-minQubit;
						if (isFunc) {
							qasmSubstring += "q" + controlQubit + ",";
						} else {
							qasmSubstring += "q[" + controlQubit + "],";
						}
						latestX[controlQubit] = xPos;
					}

					// Add the target
					for (var j=qubit; j<qubit+copy[i]["size"]; j++) {
						if (j != qubit) {
							qasmSubstring += ",";
						}
						if (isFunc) {
							qasmSubstring += "q" + j;
						} else {
							qasmSubstring += "q[" + j + "]";
						}
					}

					// The main operation is done
					qasmSubstring += ";";

					// If it should be force added
					if (forced) {
						qasmSubstring += " // forced";
					}

					// Add the newline
					qasmSubstring += "\n";

					// Update the offset between the min and max
					for (var j=minGateQubit; j<maxGateQubit+1; j++) {
						latestX[j] = xPos;
					}

				}

			}

		}

		// Add the bit stopping the gate definition
		if (isFunc) {
			qasmSubstring += "}\n";
		} 

		// Add this section to the top if it's a function
		if (isFunc) {
			qasmString = qasmSubstring + qasmString;

		// Or to the bottom if it isn't
		} else {
			qasmString = qasmString + qasmSubstring;
		}

	}

	// Add the QASM requirements
	if (version == 2) {
		qasmString = "OPENQASM 2.0;\ninclude \"qelib1.inc\";\n" + qasmString;
	} else {
		qasmString = "OPENQASM 3.0;\ninclude \"stdgates.inc\";\n" + qasmString;
	}

	// Return to be turned into a file
	return qasmString;

}

// Called when the html file input selection is changed
function onFileChange(e) {

	// Create a file reader
	var input = event.target;
	var reader = new FileReader();

	// Setup the onload function
	reader.onload = function() {

		// Get the text
		var text = reader.result;

		// Hide the load window
		loadOpen = false;
		openHover = false;

		// Reset the history 
		qasmHistory = [];
		historyIndex = -1;

		// Load the QASM 
		fromQASM(text);

		// Re-sim 
		circuitUpdates = 2;

	};

	// Trigger this event
	reader.readAsText(input.files[0]);

}

// Load the gates from a QASM string
function fromQASM(qasmString, noCameraUpdate=false) {

	// Split into the different lines
	var lines = qasmString.split("\n");

	// Things to figure out
	var numQubitsRequired = 0;
	var regToQubit = {};
	var regSizes = {};
	var latestX = [];
	var currentFunc = -1;
	var funIDtoOG = {};
	var gateOffsetX = 0;
	var gateOffsetYMin = 0;
	var gateOffsetYMax = 0;

	// Reset things
	gates = gatesInit.slice();
	nextID = 0;
	nextFunctionID = 0;

	// Split the lines into different sections 
	var sectionStartEnds = [];
	var startedAt = -1;
	var currentType = -1;
	for (var i=1; i<lines.length; i++) {
		
		// If it's a comment, split without replacing commas
		if (lines[i].substr(0,2) == "//") {
			var words = lines[i].replace(/\s+/g," ").split(" ");

		// Split into components
		} else {
			var words = lines[i].replace(/;/g,"").replace(/,/g," ").replace(/\s+/g," ").split(" ");
		}

		// Load comments as text objects 
		if (words[0] == "//" && words.length >= 4) {

			// Extract the info
			var xPos = parseInt(words[1]);
			var yPos = parseInt(words[2]);
			var text = words.slice(3,words.length).join(" ");
			ctx.font = fontSize + "px Arial";
			var textWidth = ctx.measureText(text).width;

			// Ensure it's valid
			if (!isNaN(xPos) && !isNaN(yPos) && text.length > 0) {

				// Add the gate object
				gates.push({"id": nextID, "letter": "text"+text, "x": xPos, "y": yPos, "size": Math.max(1, Math.ceil(textWidth/gridX)), "og": -1, "draggable": true, "attached":[]})
				nextID += 1;

				// If it's a link
				if (text.substr(0,4) == "http") {

					// Create a go button 
					gates[gates.length-1]["attached"].push(nextID);
					gates.push({"id": nextID, "letter": "go", "x": xPos+gates[gates.length-1]["size"], "y": yPos, "size": 1, "draggable": true, "og": nextID-1, "attached":[]})
					nextID += 1;

				}

			}

		// When reaching the main section
		} else if (words[0] == "qubit" || words[0] == "qreg") {

			// If in something before, push it
			if (startedAt >= 0) {
				sectionStartEnds.push([startedAt, i-1, currentType]);
			}

			// Now in the main section
			startedAt = i;
			currentType = -1;

		// When reaching a function
		} else if (words[0] == "gate" && words[1][0] == "f") {

			// If in something before, push it
			if (startedAt >= 0) {
				sectionStartEnds.push([startedAt, i-1, currentType]);
			}

			// Now in a function
			startedAt = i;
			currentType = parseInt(words[1].substr(1));

		}

	}
	
	// If in something at the end, push it
	if (startedAt >= 0) {
		sectionStartEnds.push([startedAt, i-1, currentType]);
	}

	// Sort this so the main section goes first
	sectionStartEnds.sort(function(a, b) {return a[2] - b[2];});

	// For each of these sections
	for (var n=0; n<sectionStartEnds.length; n++) {

		// Iterate over the lines within this section
		for (var i=sectionStartEnds[n][0]; i<sectionStartEnds[n][1]+1; i++) {

			// Ignore any blank lines
			if (lines[i].length > 0) {

				// Ignore comments
				if (lines[i][0] != "/" && lines[i] != "include" && lines[i] != "{") {

					// Split into components
					var words = lines[i].replace(/;/g,"").replace(/,/g," ").replace(/\s+/g," ").split(" ");
					
					// If position stated explicitly 
					var explicitPosition = false;
					var explicitX = 0;
					var explicitY = 0;
					var forced = false;
					var startOfComment = words.indexOf("//");
					if (startOfComment >= 0) {

						// If forcing an identity
						if (words[startOfComment+1] == "forced") {
							forced = true;

						// Otherwise it's probs pos info
						} else {

							// Extract the explicitly given positions
							explicitX = parseInt(words[startOfComment+1]);
							explicitY = parseInt(words[startOfComment+2]);

							// If valid
							if (!isNaN(explicitX) && !isNaN(explicitY)) {
								explicitPosition = true;
							}

						}

						// Remove this to make other processing easier
						words = words.slice(0, startOfComment);

					}

					// If it's specifying qubit registers 
					if (words[0] == "qubit" || words[0] == "qreg") {

						// Determine how many qubits are in this register
						var startInd = words[1].indexOf("[");
						var endInd = words[1].indexOf("]");
						var num = parseInt(words[1].substring(startInd+1, endInd));
						var name = words[1].substring(0, startInd);

						// Update the various offsets 
						numQubitsRequired += num;
						regSizes[name] = num;
						gateOffsetYMin = gateOffsetYMax + 2;
						gateOffsetYMax = gateOffsetYMin + num;

						// If being forced somewhere 
						if (explicitPosition) {

							// Add to mapping
							regToQubit[name] = explicitY;
							for (var k=0; k<num; k++) {
								regToQubit[name+"["+k+"]"] = explicitY + k;
							}

							// Ensure the x-offset array is big enough
							while (latestX.length < explicitY+num) {
								latestX.push(0);
							}
							for (var k=explicitY; k<explicitY+num; k++) {
								latestX[k] = explicitX;
							}

						// If using the automated placement
						} else {

							// Add to mapping
							regToQubit[name] = gateOffsetYMin;
							for (var k=0; k<num; k++) {
								regToQubit[name+"["+k+"]"] = gateOffsetYMin + k;
							}

							// Ensure the x-offset array is big enough
							while (latestX.length < gateOffsetYMax) {
								latestX.push(0);
							}

						}

					// If defining a new gate (function)
					} else if (words[0] == "gate" && words[1][0] == "f") {

						// Get the function id
						funcInd = parseInt(words[1].substr(1));
						currentFunc = funcInd;
						funcSize = words.length - 2;
						funIDtoOG[funcInd] = nextID;

						// Update the overall next function ID
						if (funcInd >= nextFunctionID) {
							nextFunctionID = funcInd + 1;
						}

						// If being forced somewhere 
						if (explicitPosition) {

							// Keep track of where each function starts
							gateOffsetYMin = explicitY;
							gateOffsetYMax = explicitY + funcSize + 1;

							// Add to the reg->qubit mapping, but this time it's q0 -> 0 not q[0] -> 0
							for (var k=2; k<2+funcSize; k++) {
								regToQubit[words[k]] = explicitY + k - 1;
							}

							// Ensure the x-offset array is big enough
							while (latestX.length < explicitY+funcSize+1) {
								latestX.push(0);
							}
							for (var k=explicitY; k<explicitY+funcSize+1; k++) {
								latestX[k] = explicitX+2;
							}

							gates.push({"id": nextID, "size": 1, "letter": "sub", "x": explicitX, "y": explicitY, "draggable": true, "og": -1, "attached": [], "funID": funcInd})
							nextID += 1

						} else {

							// Keep track of where each function starts
							gateOffsetYMin = gateOffsetYMax + 2;
							gateOffsetYMax = gateOffsetYMin + funcSize + 1;

							// Add to the reg->qubit mapping, but this time it's q0 -> 0 not q[0] -> 0
							for (var k=2; k<2+funcSize; k++) {
								regToQubit[words[k]] = gateOffsetYMin + k - 1;
							}

							// Ensure the x-offset array is big enough
							while (latestX.length < gateOffsetYMax) {
								latestX.push(0);
							}

							// Add the gate
							gates.push({"id": nextID, "size": 1, "letter": "sub", "x": -2, "y": gateOffsetYMin, "draggable": true, "og": -1, "attached": [], "funID": funcInd})
							nextID += 1

						}

					// If leaving a gate definition
					} else if (words[0] == "}") {
						currentFunc = -1;

					// If an identity
					} else if (words[0] == "id" && !forced) {

						// Just increase the spacing there
						target = regToQubit[words[words.length-1]];
						latestX[target] += 1;

					// If specifying a standard gate operation 
					} else {

						// If given specific registers 
						if (lines[i].indexOf("[") >= 0 || sectionStartEnds[n][2] >= 0) {

							// Count the number of controls
							var numControls = 0;
							var controlIsInv = [];
							for (var j=0; j<words.length; j++) {
								if (words[j] == "ctrl") {
									numControls += 1;
									controlIsInv.push(false);
								} else if (words[j] == "negctrl") {
									numControls += 1;
									controlIsInv.push(true);
								}
							}

							// Determine gate info
							if (currentFunc == -1) {
								var target = regToQubit[words[2*numControls+numControls+1]];
							} else {
								var target = 1 + gateOffsetYMin + parseInt(words[2*numControls+numControls+1].substr(1));
							}
							var letter = words[2*numControls];

							// Standard gate names should be uppercase for display
							if (["x", "y", "z", "s", "t", "h"].indexOf(letter) >= 0) {
								letter = letter.toUpperCase();
							}

							// If it's a swap, start with the top bit
							if (letter == "swap") {
								letter = "swaptop";
								target = regToQubit[words[2+numControls]];
							}

							// If it's an identity, change the letter
							if (letter == "id") {
								letter = "I";
							}

							// Determine control info
							var controls = []
							var controlTypes = [];
							var controlIDs = [];
							var latestPos = latestX[target];
							for (var j=0; j<numControls; j++) {
								var con = regToQubit[words[2*numControls+1+j]];
								controls.push(con);
								controlIDs.push(nextID);
								nextID += 1;
								if (controlIsInv[j]) {
									controlTypes.push("controlUnfilled");
								} else {
									controlTypes.push("controlFilled");
								}
							}

							// Determine the min and max qubits this gate affects
							var gateSize = words.length - 1 - numControls;
							var minQubit = target;
							var maxQubit = target + gateSize - 1;
							for (var j=0; j<numControls; j++) {
								if (controls[j] < minQubit) {
									minQubit = controls[j];
								}
								if (controls[j] > maxQubit) {
									maxQubit = controls[j];
								}
							}

							// Swap contains two separated gate objects
							if (letter == "swaptop") {
								var other = regToQubit[words[words.length-1]];
								minQubit = Math.min(other, minQubit);
								maxQubit = Math.max(other, maxQubit);
							}

							// Determine the latest offset required
							for (j=minQubit; j<maxQubit+1; j++) {
								if (latestX[j] > latestPos) {
									latestPos = latestX[j];
								}
							}

							// Add the gate 
							var targetID = nextID;
							if (letter[0] == "f") {
								funcInd = parseInt(letter.substr(1));
								gates.push({"id": targetID, "size": 1, "letter": "fun", "x": latestPos, "y": target, "draggable": true, "og": -1, "funID": funcInd, "attached": controlIDs.slice()})
							} else {
								gates.push({"id": targetID, "size": 1, "letter": letter, "x": latestPos, "y": target, "draggable": true, "og": -1, "attached": controlIDs.slice()})
							}
							nextID += 1;

							// If it's a swap, also add the bottom
							if (letter == "swaptop") {
								gates[gates.length-1]["attached"].unshift(nextID);
								var other = regToQubit[words[words.length-2]];
								gates.push({"id": nextID, "size": 1, "letter": "swapbottom", "x": latestPos, "y": other, "draggable": true, "og": -1, "attached": [nextID-1]})
								nextID += 1;
							}

							// Add the controls
							for (var j=0; j<numControls; j++) {
								gates.push({"id": controlIDs[j], "letter": controlTypes[j], "x": latestPos, "y": controls[j], "size": 1, "draggable": true, "og": targetID, "attached": []})
							}

							// Update the latestX for all those qubits
							for (j=minQubit; j<maxQubit+1; j++) {
								latestX[j] = latestPos+1;
							}

						// If given a whole register 
						} else {

							var targetReg = words[1];
							var regStart = regToQubit[targetReg];
							var regSize = regSizes[targetReg];
							var letter = words[0];

							// Standard gate names should be uppercase for display
							if (["x", "y", "z", "s", "t", "h"].indexOf(letter) >= 0) {
								letter = letter.toUpperCase();
							}

							// Determine the min and max qubits this gate affects
							var minQubit = regStart;
							var maxQubit = regStart + regSize - 1;

							// For each qubit that needs a gate
							for (j=minQubit; j<maxQubit+1; j++) {
								latestPos = latestX[j];

								// Add the gate 
								if (letter[0] == "f") {
									funcInd = parseInt(letter.substr(1));
									gates.push({"id": nextID, "size": 1, "letter": "fun", "x": latestPos, "y": j, "draggable": true, "og": -1, "funID": funcInd, "attached": []})
								} else {
									gates.push({"id": nextID, "size": 1, "letter": letter, "x": latestPos, "y": j, "draggable": true, "og": -1, "attached": []})
								}
								nextID += 1
								
								// Update the latestX for all those qubits
								latestX[j] = latestPos+1;

							}

						}

					}
					
				}

			}

		}

	}

	// Ensure all functions have their og set
	for (var i=0; i<gates.length; i++) {
		if (gates[i]["letter"] == "fun" && gates[i]["og"] == -1) {
			gates[i]["og"] = funIDtoOG[gates[i]["funID"]];
		}
	}

	// Recenter the camera if haven't just ctrl-z'd
	if (!noCameraUpdate) {
		
		// Get the min/maxs so know how to center everything
		var minX = 9999;
		var maxX = -9999;
		var minY = 9999;
		var maxY = -9999;
		for (var i=gateOptions; i<gates.length; i++) {
			if (gates[i]["x"] < minX) {
				minX = gates[i]["x"];
			}
			if (gates[i]["letter"].substr(0,4) == "text") {
				if (gates[i]["x"]+gates[i]["size"] > maxX) {
					maxX = gates[i]["x"]+gates[i]["size"];
				}
			} else {
				if (gates[i]["x"] > maxX) {
					maxX = gates[i]["x"];
				}
			}
			if (gates[i]["y"] < minY) {
				minY = gates[i]["y"];
			}
			if (gates[i]["y"] > maxY) {
				maxY = gates[i]["y"];
			}
		}

		// If vertical mobile, get closer to the left of the screen
		if (onMobile == 1) {
			offsetX = Math.max(0.5*gridXFixed-minX*gridX, window.innerWidth / 2 - (maxX-minX+1)*gridX / 2 - (minX+1)*gridX);
			offsetY = Math.max(3*gridYFixed-minY*gridY, window.innerHeight / 2 - (maxY-minY+1)*gridY / 2 - (minY+1)*gridY);
		} else {
			offsetX = Math.max(3*gridXFixed-minX*gridX, window.innerWidth / 2 - (maxX-minX+1)*gridX / 2 - (minX+1)*gridX);
			offsetY = Math.max(2*gridYFixed-minY*gridY, window.innerHeight / 2 - (maxY-minY+1)*gridY / 2 - (minY+1)*gridY);
		}

	}

}

// Triggered when the scroll wheel is moved
function mouseWheel(e) {

	// Only handle if the help isn't open
	if (!helpOpen) {

		// Figure out the zoom point before scaling
		var xs = (e.clientX - offsetX) / (gridX / gridXFixed);
		var ys = (e.clientY - offsetY) / (gridY / gridYFixed);

		// How fast to zoom
		var zoomSpeed = 0.05 * e.deltaY;

		// Scroll deltaY is not the same across browsers 
		if (browser == "Chrome" && onMobile == 0) {
			zoomSpeed *= 0.055;
		} else if (browser == "Firefox" && onMobile == 0) {
			zoomSpeed *= 0.010;
		}

		// Limit the scroll speed just in case
		if (zoomSpeed > 0) {
			zoomSpeed = Math.min(zoomSpeed, 0.10);
		} else {
			zoomSpeed = Math.max(zoomSpeed, -0.10);
		}

		// Change the dimensions
		var change = 1.0 - zoomSpeed;
		gridY *= change;
		gridX *= change;
		gateSize *= change;
		fontSize *= change;

		// Update now the scale has changed
		offsetX = e.clientX - xs * (gridX / gridXFixed);
		offsetY = e.clientY - ys * (gridY / gridYFixed);

	}

}

// Download text to a filename, from https://ourcodeworld.com/articles/read/189/how-to-create-a-file-and-generate-a-download-with-javascript-in-the-browser-without-a-server 
function download(filename, text) {
	var element = document.createElement('a');
	element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
	element.setAttribute('download', filename);
	element.style.display = 'none';
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}

// Convert touch -> mouse, based on https://stackoverflow.com/questions/1517924/javascript-mapping-touch-events-to-mouse-events
function touchHandler(event) {

	// Get the touch info
	var touches = event.changedTouches;
	var first = touches[0];

	// When the finger is first put down
	if (event.type == "touchstart") {

		// If starting a pinch zoom 
		if (event.targetTouches.length == 2) {
			isPinching = true;
			lastPinchDist = -1;
		} else {
			isPinching = false;
		}

		// First act as a hover
		var simulatedEvent = new MouseEvent("mousemove", {
			clientX: first.clientX,
			clientY: first.clientY+mobileOffsetY,
			movementX: 0,
			movementY: 0,
		});
		first.target.dispatchEvent(simulatedEvent);

		// Then trigger down
		var simulatedEvent = new MouseEvent("mousedown", {
			clientX: first.clientX,
			clientY: first.clientY+mobileOffsetY,
		});
		first.target.dispatchEvent(simulatedEvent);

		// Log the latest touch location
		prevTouchX = first.clientX;
		prevTouchY = first.clientY;

	// If the finger is dragged along the screen
	} else if (event.type == "touchmove") {

		// If currently has two fingers on screen
		if (isPinching) {

			// Get the distance between them
			var dist = Math.hypot(event.targetTouches[0].clientX - event.targetTouches[1].clientX,
								event.targetTouches[0].clientY - event.targetTouches[1].clientY);

			// If it's not the first trigger
			if (lastPinchDist != -1) {

				// Whether expanding or contracting 
				var delta = 0.06*Math.abs(dist-lastPinchDist);
				if (dist > lastPinchDist) {
					delta = -delta;
				}

				// Mouse wheel event 
				var simulatedEvent = new WheelEvent("wheel", {
					clientX: (event.targetTouches[0].clientX+event.targetTouches[1].clientX)/2,
					clientY: (event.targetTouches[0].clientY+event.targetTouches[1].clientY)/2,
					deltaY: delta,
				});

				// Trigger the event
				first.target.dispatchEvent(simulatedEvent);

			}

			// Update the last pinch distance
			lastPinchDist = dist;

		} else {

			// Drag event
			var simulatedEvent = new MouseEvent("mousemove", {
				clientX: first.clientX,
				clientY: first.clientY+mobileOffsetY,
				movementX: first.clientX - prevTouchX,
				movementY: first.clientY - prevTouchY,
			});

			// Log the latest touch location
			prevTouchX = first.clientX;
			prevTouchY = first.clientY;

			// Trigger the event
			first.target.dispatchEvent(simulatedEvent);

		}

	// When the finger is lifted up
	} else if (event.type == "touchend" || event.type == "touchcancel") {

		// Mouse up event
		var simulatedEvent = new MouseEvent("mouseup", {
			clientX: first.clientX,
			clientY: first.clientY+mobileOffsetY,
		});

		// Trigger the event
		first.target.dispatchEvent(simulatedEvent);

		// Stop pinching if pinching
		isPinching = false;

	}

	// Don't do whatever the default is
	event.preventDefault();

}

// Finish up the svg, adding the wrapper etc. 
function svgWrap() {

	// Go through and adjust all the x/y values so they start at 0
	for (var i=0; i<svgString.length; i++) {

		// Replace the x values
		if (svgString.substr(i, 3) == "x=\"") {

			// Figure out where it starts/stops
			var numStart = i+3;
			var numEnd = i+svgString.substr(i+3).indexOf("\"")+3;

			// Get the value, then update it based on the minX
			var oldVal = parseFloat(svgString.substring(numStart, numEnd));
			var newVal = oldVal - svgMinX + svgPadding;
			svgString = svgString.substring(0, numStart) + newVal + svgString.substr(numEnd);

		// Replace the x values (for lines)
		} else if (svgString.substr(i, 4) == "x1=\"" || svgString.substr(i, 4) == "x2=\"") {

			// Figure out where it starts/stops
			var numStart = i+4;
			var numEnd = i+svgString.substr(i+4).indexOf("\"")+4;

			// Get the value, then update it based on the minX
			var oldVal = parseFloat(svgString.substring(numStart, numEnd));
			var newVal = oldVal - svgMinX + svgPadding;
			svgString = svgString.substring(0, numStart) + newVal + svgString.substr(numEnd);

		// Replace the y values
		} else if (svgString.substr(i, 3) == "y=\"") {

			// Figure out where it starts/stops
			var numStart = i+3;
			var numEnd = i+svgString.substr(i+3).indexOf("\"")+3;

			// Get the value, then update it based on the minX
			var oldVal = parseFloat(svgString.substring(numStart, numEnd));
			var newVal = oldVal - svgMinY + svgPadding;
			svgString = svgString.substring(0, numStart) + newVal + svgString.substr(numEnd);

		// Replace the y values (for lines)
		} else if (svgString.substr(i, 4) == "y1=\"" || svgString.substr(i, 4) == "y2=\"") {

			// Figure out where it starts/stops
			var numStart = i+4;
			var numEnd = i+svgString.substr(i+4).indexOf("\"")+4;

			// Get the value, then update it based on the minX
			var oldVal = parseFloat(svgString.substring(numStart, numEnd));
			var newVal = oldVal - svgMinY + svgPadding;
			svgString = svgString.substring(0, numStart) + newVal + svgString.substr(numEnd);

		// Replace the values in any arc calls 
		} else if (svgString.substr(i, 3) == "\"M ") {

			// Figure out where it starts/stops
			var sectionStart = i+3;
			var sectionEnd = i+3+svgString.substr(i+3).indexOf("\"");

			// Split this section based on spaces for easier processing
			var spl = svgString.substring(sectionStart, sectionEnd).split(" ");

			// For every float, adjust
			spl[0] = spl[0] - svgMinX + svgPadding;
			spl[1] = spl[1] - svgMinY + svgPadding;
			spl[3] = spl[3] - svgMinX + svgPadding;
			spl[4] = spl[4] - svgMinY + svgPadding;
			spl[5] = spl[5] - svgMinX + svgPadding;
			spl[6] = spl[6] - svgMinY + svgPadding;

			// Combine the array and put it back
			var reverted = spl.join(" ");
			svgString = svgString.substring(0, sectionStart) + reverted + svgString.substr(sectionEnd);

		}

	}

	// Get the width and height of the svg
	var svgWidth = svgMaxX - svgMinX + svgPadding*2;
	var svgHeight = svgMaxY - svgMinY + svgPadding*2;

	// Add the svg header
	svgString = "<svg width=\"" + svgWidth + "\" height=\"" + svgHeight + "\" xmlns=\"http://www.w3.org/2000/svg\">\n" + svgString + "</svg>"
}

// Place next to each fillRect that should be copied to the svg 
function svgRect(x, y, w, h, col) {
	svgString += "<rect x=\"" + x + "\" y=\"" + y + "\" width=\"" + w + "\" height=\"" + h + "\" fill=\"" + col + "\"/>\n";
	svgMinX = Math.min(svgMinX, x);
	svgMinY = Math.min(svgMinY, y);
	svgMaxX = Math.max(svgMaxX, x+w);
	svgMaxY = Math.max(svgMaxY, y+h);
}

// Place next to each circle/arc that should be copied to the svg 
function svgCircle(x, y, r, fill, stroke, strokeWidth) {
	svgString += "<circle cx=\"" + x + "\" cy=\"" + y + "\" r=\"" + r + "\" fill=\"" + fill + "\" stroke-width=\"" + strokeWidth + "\" stroke=\"" + stroke + "\"/>\n";
	svgMinX = Math.min(svgMinX, x-r);
	svgMinY = Math.min(svgMinY, y-r);
	svgMaxX = Math.max(svgMaxX, x+r);
	svgMaxY = Math.max(svgMaxY, y+r);
}

// Place next to each fillText that should be copied to the svg 
function svgText(t, x, y, size, w, col) {
	svgString += "<text x=\"" + x + "\" y=\"" + y + "\" style=\"font-family:Arial\" font-size=\"" + size + "\" fill=\"" + col + "\">" + t + "</text>\n";
	svgMinX = Math.min(svgMinX, x);
	svgMinY = Math.min(svgMinY, y);
	svgMaxX = Math.max(svgMaxX, x+w);
	svgMaxY = Math.max(svgMaxY, y+size);
}

// Place next to each line stroke that should be copied to the svg 
function svgLine(x1, y1, x2, y2, col, w) {
	svgString += "<line x1=\"" + x1 + "\" y1=\"" + y1 + "\" x2=\"" + x2 + "\" y2=\"" + y2 + "\" stroke=\"" + col + "\" stroke-width=\"" + w + "\"/>\n";
	svgMinX = Math.min(svgMinX, x1, x2);
	svgMinY = Math.min(svgMinY, y1, y2);
	svgMaxX = Math.max(svgMaxX, x1, x2);
	svgMaxY = Math.max(svgMaxY, y1, y2);
}

// Place next to each fillText that should be copied to the svg 
function svgArc(x1, y1, c1, c2, x2, y2, col, w) {
	svgString += "<path d=\"M " + x1 + " " + y1 + " Q " + c1 + " " + c2 + " " + x2 + " " + y2 + "\" fill=\"none\" stroke=\"" + col + "\" stroke-width=\"" + w + "\"/>\n";
	svgMinX = Math.min(svgMinX, x1, x2);
	svgMinY = Math.min(svgMinY, y1, y2);
	svgMaxX = Math.max(svgMaxX, x1, x2);
	svgMaxY = Math.max(svgMaxY, y1, y2);
}

// Shorthand
function floor(x) {
	return Math.floor(x);
}
		
</script>
</head>
<body onresize="init(false,false)" onload="init(true,true)" onhashchange="init(false,true)">
<canvas id="view"></canvas>
<input id="fileIn" onchange="onFileChange(event);" type="file" style="top:10em; display:none;" accept=".qasm"/>
<input id="hiddenText" oninput="onTextPaste(event);" style="top:10em;"></div>
<a id="hiddenURL" href="" target="_blank" rel="noopener noreferrer"></a>
</body>
</html>
